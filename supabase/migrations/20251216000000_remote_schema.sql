create type "public"."chat_participant_role" as enum ('owner', 'admin', 'member');

create type "public"."preference_status" as enum ('hidden', 'blocked');


  create table "public"."activity_field_keywords" (
    "id" bigint generated by default as identity not null,
    "activity_field" text not null,
    "keyword" text not null,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."activity_field_keywords" enable row level security;


  create table "public"."admin_activity_logs" (
    "id" uuid not null default gen_random_uuid(),
    "action" text not null,
    "details" jsonb default '{}'::jsonb,
    "created_at" timestamp with time zone default now(),
    "admin_profile_id" uuid not null,
    "target_admin_profile_id" uuid
      );


alter table "public"."admin_activity_logs" enable row level security;


  create table "public"."admins" (
    "email" text not null,
    "role" text default 'admin'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "permissions" text[] default ARRAY[]::text[],
    "username" text,
    "profile_id" uuid not null
      );


alter table "public"."admins" enable row level security;


  create table "public"."badges" (
    "id" uuid not null default gen_random_uuid(),
    "name" text not null,
    "icon" text not null,
    "description" text,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."badges" enable row level security;


  create table "public"."chat_messages" (
    "id" uuid not null default gen_random_uuid(),
    "room_id" uuid not null,
    "sender_id" uuid not null,
    "content" text not null,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "attachments" jsonb default '[]'::jsonb,
    "type" text default 'text'::text
      );


alter table "public"."chat_messages" enable row level security;


  create table "public"."chat_participants" (
    "room_id" uuid not null,
    "user_id" uuid not null,
    "joined_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "last_read_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "is_pinned" boolean default false,
    "pinned_at" timestamp with time zone,
    "is_notification_enabled" boolean default true,
    "role" public.chat_participant_role not null default 'member'::public.chat_participant_role
      );


alter table "public"."chat_participants" enable row level security;


  create table "public"."chat_room_invitations" (
    "id" uuid not null default gen_random_uuid(),
    "room_id" uuid not null,
    "inviter_id" uuid not null,
    "invitee_id" uuid not null,
    "status" text not null default 'pending'::text,
    "message" text,
    "sent_at" timestamp with time zone default now(),
    "responded_at" timestamp with time zone,
    "expires_at" timestamp with time zone default (now() + '7 days'::interval),
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."chat_room_invitations" enable row level security;


  create table "public"."chat_rooms" (
    "id" uuid not null default gen_random_uuid(),
    "type" text not null,
    "title" text,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "is_pinned" boolean default false,
    "pinned_at" timestamp with time zone,
    "is_notification_enabled" boolean default true,
    "project_id" uuid,
    "collaboration_id" uuid,
    "created_by" uuid,
    "notice_message_id" uuid
      );


alter table "public"."chat_rooms" enable row level security;


  create table "public"."collaboration_applications" (
    "id" uuid not null default gen_random_uuid(),
    "collaboration_id" uuid not null,
    "applicant_id" uuid not null,
    "status" text not null default 'pending'::text,
    "cover_letter" text not null,
    "budget_range" text,
    "duration" text,
    "portfolio_links" jsonb default '[]'::jsonb,
    "resume_url" text,
    "attachments" jsonb default '[]'::jsonb,
    "skills" text[] default '{}'::text[],
    "experience_years" integer,
    "availability" text,
    "applied_date" timestamp with time zone default now(),
    "reviewed_date" timestamp with time zone,
    "response_date" timestamp with time zone,
    "is_read" boolean default false,
    "is_shortlisted" boolean default false,
    "reviewer_id" uuid,
    "reviewer_note" text,
    "rejection_reason" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "is_hidden_by_applicant" boolean default false,
    "is_hidden_by_reviewer" boolean default false
      );


alter table "public"."collaboration_applications" enable row level security;


  create table "public"."collaboration_invitations" (
    "id" uuid not null default gen_random_uuid(),
    "collaboration_id" uuid not null,
    "inviter_id" uuid not null,
    "invitee_id" uuid not null,
    "status" text not null default 'pending'::text,
    "message" text,
    "question" text,
    "question_date" timestamp with time zone,
    "answer" text,
    "answer_date" timestamp with time zone,
    "position" text,
    "responsibilities" text,
    "compensation" text,
    "sent_date" timestamp with time zone default now(),
    "viewed_date" timestamp with time zone,
    "response_date" timestamp with time zone,
    "expiry_date" timestamp with time zone,
    "is_read" boolean default false,
    "is_starred" boolean default false,
    "rejection_reason" text,
    "acceptance_note" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "is_hidden_by_inviter" boolean default false,
    "is_hidden_by_invitee" boolean default false
      );


alter table "public"."collaboration_invitations" enable row level security;


  create table "public"."collaboration_members" (
    "id" uuid not null default gen_random_uuid(),
    "collaboration_id" uuid not null,
    "user_id" uuid not null,
    "position" text not null,
    "responsibilities" text,
    "status" text not null default 'active'::text,
    "is_leader" boolean default false,
    "can_invite" boolean default false,
    "can_edit" boolean default false,
    "contribution" text,
    "profit_share" numeric(5,2),
    "joined_date" timestamp with time zone default now(),
    "left_date" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."collaboration_members" enable row level security;


  create table "public"."collaboration_stats" (
    "collaboration_id" uuid not null,
    "view_count" integer default 0,
    "bookmark_count" integer default 0,
    "last_viewed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."collaboration_stats" enable row level security;


  create table "public"."collaborations" (
    "id" uuid not null default gen_random_uuid(),
    "created_by" uuid not null,
    "title" text not null,
    "description" text not null,
    "category" text not null,
    "status" text not null default 'open'::text,
    "cover_image_url" text not null,
    "requirements" text default '[]'::jsonb,
    "tags" text[] default '{}'::text[],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "duration" text,
    "work_type" text not null default 'remote'::text,
    "collaboration_type" text default 'project_based'::text,
    "skills" text[] default '{}'::text[],
    "budget_range" text,
    "budget_min" numeric(12,2),
    "budget_max" numeric(12,2),
    "budget_currency" text default 'KRW'::text,
    "scheduled_start_date" timestamp with time zone,
    "scheduled_end_date" timestamp with time zone,
    "team_size" integer,
    "current_team_size" integer default 1,
    "min_experience_years" integer,
    "location" text,
    "images" text[] default '{}'::text[],
    "video_url" text,
    "goals" text,
    "expected_outcome" text,
    "profit_sharing" text,
    "view_count" integer default 0,
    "bookmark_count" integer default 0,
    "invitation_count" integer default 0,
    "application_count" integer default 0,
    "is_featured" boolean default false,
    "is_urgent" boolean default false,
    "is_remote_friendly" boolean default false,
    "visibility" text default 'public'::text,
    "published_at" timestamp with time zone,
    "started_at" timestamp with time zone,
    "closed_at" timestamp with time zone,
    "brief_description" text,
    "benefits" jsonb default '[]'::jsonb,
    "files" jsonb default '[]'::jsonb,
    "workflow_steps" jsonb default '[]'::jsonb,
    "goal" text
      );


alter table "public"."collaborations" enable row level security;


  create table "public"."homepage_slider_images" (
    "id" uuid not null default gen_random_uuid(),
    "image_url" text,
    "link_url" text,
    "background_color" text,
    "display_order" integer not null default 0,
    "is_active" boolean not null default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "updated_by" uuid,
    "video_url" text,
    "media_type" text default 'image'::text
      );


alter table "public"."homepage_slider_images" enable row level security;


  create table "public"."homepage_trending_projects" (
    "id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "tag" text not null,
    "color" text not null,
    "display_order" integer not null default 0,
    "is_active" boolean not null default true,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "created_by" uuid,
    "updated_by" uuid,
    "image_url" text
      );


alter table "public"."homepage_trending_projects" enable row level security;


  create table "public"."inquiries" (
    "inquiry_id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "username" text,
    "inquiry_type" text not null,
    "subject" text not null,
    "contents" text not null,
    "created_at" timestamp with time zone default now(),
    "status" text not null default 'pending'::text,
    "answered_at" timestamp with time zone,
    "answer_content" text,
    "attachments" jsonb default '[]'::jsonb,
    "manager_profile_id" uuid,
    "nickname" text,
    "email" text
      );


alter table "public"."inquiries" enable row level security;


  create table "public"."lounge_bookmarks" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "magazine_id" uuid,
    "folder_name" text,
    "note" text,
    "created_at" timestamp with time zone default now(),
    "project_id" uuid,
    "collaboration_id" uuid
      );


alter table "public"."lounge_bookmarks" enable row level security;


  create table "public"."lounge_comment_likes" (
    "id" uuid not null default extensions.uuid_generate_v4(),
    "comment_id" uuid not null,
    "user_id" uuid not null,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."lounge_comment_likes" enable row level security;


  create table "public"."lounge_comments" (
    "id" uuid not null default gen_random_uuid(),
    "magazine_id" uuid,
    "parent_id" uuid,
    "author_id" uuid not null,
    "content" text not null,
    "like_count" integer default 0,
    "reply_count" integer default 0,
    "status" text not null default 'active'::text,
    "is_edited" boolean default false,
    "is_reported" boolean default false,
    "report_count" integer default 0,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "deleted_at" timestamp with time zone,
    "project_id" uuid,
    "collaboration_id" uuid,
    "author_role" text not null default 'fan'::text
      );


alter table "public"."lounge_comments" enable row level security;


  create table "public"."lounge_likes" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "magazine_id" uuid,
    "comment_id" uuid,
    "created_at" timestamp with time zone default now(),
    "project_id" uuid,
    "collaboration_id" uuid,
    "is_canceled" boolean not null default false,
    "actor_role" text,
    "actor_profile_id" uuid,
    "actor_name" text,
    "actor_avatar_url" text
      );


alter table "public"."lounge_likes" enable row level security;


  create table "public"."magazines" (
    "id" uuid not null default gen_random_uuid(),
    "author_id" uuid,
    "title" text not null,
    "subtitle" text,
    "content" text not null,
    "excerpt" text,
    "category" text not null,
    "tags" text[] default '{}'::text[],
    "cover_image_url" text not null,
    "images" text[] default '{}'::text[],
    "video_url" text,
    "reading_time" integer default 5,
    "difficulty_level" text,
    "view_count" integer default 0,
    "like_count" integer default 0,
    "comment_count" integer default 0,
    "bookmark_count" integer default 0,
    "share_count" integer default 0,
    "status" text not null default 'draft'::text,
    "is_featured" boolean default false,
    "is_trending" boolean default false,
    "is_editor_pick" boolean default false,
    "meta_title" text,
    "meta_description" text,
    "meta_keywords" text[] default '{}'::text[],
    "slug" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "published_at" timestamp with time zone,
    "display_order" integer not null default 9999,
    "related_project" uuid,
    "is_active" boolean default true,
    "updated_by" uuid,
    "content_blocks" jsonb default '[]'::jsonb
      );


alter table "public"."magazines" enable row level security;


  create table "public"."partner_stats" (
    "profile_id" uuid not null,
    "rating" numeric,
    "review_count" integer,
    "completed_projects" integer,
    "region" text,
    "matching_rate" integer,
    "response_rate" integer,
    "response_time" text,
    "career" text,
    "is_online" boolean default false,
    "is_verified" boolean default false,
    "portfolio_images" jsonb default '[]'::jsonb,
    "career_history" jsonb default '[]'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );



  create table "public"."partnership_inquiries" (
    "id" uuid not null default gen_random_uuid(),
    "sender_id" uuid not null,
    "receiver_id" uuid not null,
    "company_name" text not null,
    "contact_name" text not null,
    "email" text not null,
    "phone" text not null,
    "project_type" text not null,
    "budget_range" text not null,
    "duration" text not null,
    "description" text not null,
    "goals" text not null,
    "experience" text,
    "attachments" jsonb default '[]'::jsonb,
    "status" text not null default 'pending'::text,
    "response_message" text,
    "response_action" text,
    "received_date" timestamp with time zone default now(),
    "response_date" timestamp with time zone,
    "is_read" boolean default false,
    "is_starred" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."partnership_inquiries" enable row level security;


  create table "public"."profile_artists" (
    "profile_id" uuid not null,
    "artist_name" text not null,
    "activity_field" text not null default ''::text,
    "specialized_roles" text[] not null default '{}'::text[],
    "cover_image_url" text,
    "highlight_keywords" text[] not null default '{}'::text[],
    "bio" text not null,
    "portfolio_url" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone,
    "tags" text[] not null default '{}'::text[],
    "logo_image_url" text,
    "is_active" boolean not null default true,
    "region" text,
    "career" text,
    "career_history" jsonb default '[]'::jsonb,
    "is_verified" boolean default false,
    "portfolios" jsonb default '[]'::jsonb,
    "careers" jsonb default '[]'::jsonb
      );


alter table "public"."profile_artists" enable row level security;


  create table "public"."profile_brands" (
    "profile_id" uuid not null,
    "brand_name" text not null,
    "target_audiences" text[] not null default '{}'::text[],
    "preferred_creator_types" text[] not null default '{}'::text[],
    "cover_image_url" text not null,
    "logo_image_url" text not null,
    "collaboration_types" text[] not null default '{}'::text[],
    "monthly_budget" text not null,
    "website_url" text,
    "sns_channel" text,
    "contact_info" text not null,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone,
    "approval_status" text not null default 'pending'::text,
    "approved_at" timestamp with time zone not null default now(),
    "approved_by" text,
    "business_registration_number" text not null default '--'::text,
    "is_active" boolean not null default true,
    "region" text,
    "description" text,
    "tags" text[],
    "activity_field" text,
    "portfolios" jsonb default '[]'::jsonb,
    "careers" jsonb default '[]'::jsonb
      );


alter table "public"."profile_brands" enable row level security;


  create table "public"."profile_creatives" (
    "profile_id" uuid not null,
    "profile_image_url" text,
    "nickname" text not null,
    "sns_channels" jsonb not null default '[]'::jsonb,
    "acquisition_source" text not null,
    "invitation_code" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone,
    "main_sns_channel" jsonb not null,
    "is_active" boolean not null default true,
    "activity_field" text,
    "tags" text[] default '{}'::text[],
    "bio" text,
    "region" text,
    "career" text,
    "career_history" jsonb default '[]'::jsonb,
    "is_verified" boolean default false,
    "portfolios" jsonb default '[]'::jsonb,
    "careers" jsonb default '[]'::jsonb,
    "cover_image_url" text
      );


alter table "public"."profile_creatives" enable row level security;


  create table "public"."profile_fans" (
    "profile_id" uuid not null,
    "interests" text[] not null default '{}'::text[],
    "persona" text not null,
    "specific_interests" text[] not null default '{}'::text[],
    "preferred_regions" text[] not null default '{}'::text[],
    "notification_preferences" text[] not null default '{}'::text[],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone,
    "is_active" boolean not null default true,
    "profile_image_url" text
      );


alter table "public"."profile_fans" enable row level security;


  create table "public"."profiles" (
    "id" uuid not null,
    "username" text,
    "avatar_url" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "nickname" text default ''::text,
    "terms_agreed_at" timestamp with time zone default now(),
    "marketing_agreed_at" timestamp with time zone default now(),
    "banned_until" timestamp with time zone,
    "last_access" timestamp with time zone,
    "email" text,
    "roles" text[] default ARRAY[]::text[],
    "is_online" boolean default false,
    "privacy_agreed_at" timestamp with time zone,
    "project_recommendation_agreed_at" timestamp with time zone,
    "partner_matching_agreed_at" timestamp with time zone,
    "events_agreed_at" timestamp with time zone
      );


alter table "public"."profiles" enable row level security;


  create table "public"."project_applications" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid not null,
    "applicant_id" uuid not null,
    "status" text not null default 'pending'::text,
    "cover_letter" text not null,
    "budget_range" text,
    "duration" text,
    "portfolio_links" jsonb default '[]'::jsonb,
    "resume_url" text,
    "attachments" jsonb default '[]'::jsonb,
    "skills" text[] default '{}'::text[],
    "experience_years" integer,
    "availability" text,
    "applied_date" timestamp with time zone default now(),
    "reviewed_date" timestamp with time zone,
    "response_date" timestamp with time zone,
    "is_read" boolean default false,
    "is_shortlisted" boolean default false,
    "reviewer_id" uuid,
    "reviewer_note" text,
    "rejection_reason" text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "is_hidden_by_applicant" boolean default false,
    "is_hidden_by_reviewer" boolean default false
      );


alter table "public"."project_applications" enable row level security;


  create table "public"."project_comments" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid not null,
    "user_id" uuid not null,
    "parent_id" uuid,
    "content" text not null,
    "like_count" integer default 0,
    "reply_count" integer default 0,
    "is_edited" boolean default false,
    "is_deleted" boolean default false,
    "is_pinned" boolean default false,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "deleted_at" timestamp with time zone
      );


alter table "public"."project_comments" enable row level security;


  create table "public"."project_members" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid not null,
    "user_id" uuid not null,
    "position" text not null,
    "responsibilities" text,
    "status" text not null default 'active'::text,
    "is_leader" boolean default false,
    "can_invite" boolean default false,
    "can_edit" boolean default false,
    "compensation" text,
    "payment_amount" numeric(12,2),
    "joined_date" timestamp with time zone default now(),
    "left_date" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."project_members" enable row level security;


  create table "public"."project_proposals" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid not null,
    "sender_id" uuid not null,
    "receiver_id" uuid not null,
    "status" text not null default 'pending'::text,
    "message" text,
    "comment" text,
    "budget_range" text,
    "duration" text,
    "position" text,
    "responsibilities" text,
    "sent_date" timestamp with time zone default now(),
    "viewed_date" timestamp with time zone,
    "response_date" timestamp with time zone,
    "expiry_date" timestamp with time zone,
    "is_read" boolean default false,
    "is_starred" boolean default false,
    "rejection_reason" text,
    "acceptance_note" text,
    "attachments" jsonb default '[]'::jsonb,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "question" text,
    "question_date" timestamp with time zone,
    "answer" text,
    "answer_date" timestamp with time zone,
    "is_hidden_by_sender" boolean default false,
    "is_hidden_by_receiver" boolean default false,
    "question_answers" jsonb not null default '[]'::jsonb
      );


alter table "public"."project_proposals" enable row level security;


  create table "public"."project_stats" (
    "project_id" uuid not null,
    "view_count" integer default 0,
    "bookmark_count" integer default 0,
    "last_viewed_at" timestamp with time zone,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now()
      );


alter table "public"."project_stats" enable row level security;


  create table "public"."projects" (
    "id" uuid not null default gen_random_uuid(),
    "created_by" uuid not null,
    "title" text not null,
    "description" text not null,
    "category" text not null,
    "status" text not null default 'draft'::text,
    "cover_image_url" text not null,
    "budget_range" text,
    "deadline" timestamp with time zone,
    "tags" text[] default '{}'::text[],
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "skills" text[] default '{}'::text[],
    "budget_min" numeric(12,2),
    "budget_max" numeric(12,2),
    "budget_type" text not null default 'negotiable'::text,
    "budget_currency" text default 'KRW'::text,
    "duration" text,
    "scheduled_start_date" timestamp with time zone,
    "scheduled_end_date" timestamp with time zone,
    "team_size" integer,
    "min_experience_years" integer,
    "work_type" text not null default 'remote'::text,
    "location" text,
    "images" text[] default '{}'::text[],
    "video_url" text,
    "requirements" text,
    "deliverables" text,
    "payment_terms" text,
    "contract_type" text,
    "view_count" integer default 0,
    "bookmark_count" integer default 0,
    "proposal_count" integer default 0,
    "application_count" integer default 0,
    "is_featured" boolean default false,
    "is_urgent" boolean default false,
    "is_remote_friendly" boolean default false,
    "visibility" text default 'public'::text,
    "published_at" timestamp with time zone,
    "started_at" timestamp with time zone,
    "closed_at" timestamp with time zone,
    "workflow_steps" jsonb default '[]'::jsonb,
    "files" jsonb default '[]'::jsonb,
    "current_team_size" integer default 1,
    "goal" text,
    "is_trending" boolean not null default false,
    "display_order" integer
      );


alter table "public"."projects" enable row level security;


  create table "public"."reviews" (
    "id" uuid not null default gen_random_uuid(),
    "project_id" uuid,
    "collaboration_id" uuid,
    "reviewer_id" uuid not null,
    "reviewee_id" uuid,
    "rating" numeric not null,
    "content" text not null,
    "is_verified" boolean not null default false,
    "is_visible" boolean not null default true,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
      );


alter table "public"."reviews" enable row level security;


  create table "public"."search_history" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "query" text not null,
    "search_type" text,
    "created_at" timestamp with time zone not null default now()
      );


alter table "public"."search_history" enable row level security;


  create table "public"."server_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "title" text not null,
    "body" text not null,
    "type" text not null,
    "audiences" text[] not null default '{all}'::text[],
    "locale" text,
    "app_min_version" text,
    "app_max_version" text,
    "starts_at" timestamp with time zone,
    "ends_at" timestamp with time zone,
    "is_active" boolean not null default true,
    "priority" integer not null default 0,
    "require_ack" boolean not null default false,
    "link_url" text,
    "created_by" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "image_urls" text[] default '{}'::text[]
      );


alter table "public"."server_notifications" enable row level security;


  create table "public"."user_badges" (
    "user_id" uuid not null,
    "badge_id" uuid not null,
    "obtained_at" timestamp with time zone default now()
      );


alter table "public"."user_badges" enable row level security;


  create table "public"."user_bookmarks" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "project_id" uuid,
    "collaboration_id" uuid,
    "created_at" timestamp with time zone default now()
      );


alter table "public"."user_bookmarks" enable row level security;


  create table "public"."user_collaboration_preferences" (
    "profile_id" uuid not null,
    "collaboration_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "status" public.preference_status not null default 'hidden'::public.preference_status,
    "reason" text
      );


alter table "public"."user_collaboration_preferences" enable row level security;


  create table "public"."user_notification_settings" (
    "user_id" uuid not null,
    "notification_type" text not null,
    "is_enabled" boolean default true,
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."user_notification_settings" enable row level security;


  create table "public"."user_notifications" (
    "id" uuid not null default gen_random_uuid(),
    "receiver_id" uuid not null,
    "type" text not null,
    "title" text not null,
    "content" text not null,
    "related_id" uuid,
    "related_type" text,
    "is_read" boolean default false,
    "created_at" timestamp with time zone not null default now(),
    "metadata" jsonb default '{}'::jsonb
      );


alter table "public"."user_notifications" enable row level security;


  create table "public"."user_partner_preferences" (
    "profile_id" uuid not null,
    "partner_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "status" public.preference_status not null default 'hidden'::public.preference_status,
    "reason" text
      );


alter table "public"."user_partner_preferences" enable row level security;


  create table "public"."user_project_preferences" (
    "profile_id" uuid not null,
    "project_id" uuid not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "status" public.preference_status not null default 'hidden'::public.preference_status,
    "reason" text
      );


alter table "public"."user_project_preferences" enable row level security;


  create table "public"."user_push_tokens" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "token" text not null,
    "provider" text not null default 'fcm'::text,
    "device_type" text,
    "created_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
      );


alter table "public"."user_push_tokens" enable row level security;


  create table "public"."user_user_preferences" (
    "user_id" uuid not null,
    "target_id" uuid not null,
    "preference_type" text not null,
    "created_at" timestamp with time zone default now(),
    "target_type" text not null default 'user'::text,
    "actor_role" text,
    "actor_profile_id" uuid,
    "actor_name" text,
    "actor_avatar_url" text
      );


alter table "public"."user_user_preferences" enable row level security;

CREATE UNIQUE INDEX activity_field_keywords_activity_field_keyword_uniq ON public.activity_field_keywords USING btree (activity_field, keyword);

CREATE UNIQUE INDEX activity_field_keywords_pkey ON public.activity_field_keywords USING btree (id);

CREATE UNIQUE INDEX admin_activity_logs_pkey ON public.admin_activity_logs USING btree (id);

CREATE UNIQUE INDEX admins_email_key ON public.admins USING btree (email);

CREATE UNIQUE INDEX admins_pkey ON public.admins USING btree (profile_id);

CREATE UNIQUE INDEX badges_name_key ON public.badges USING btree (name);

CREATE UNIQUE INDEX badges_pkey ON public.badges USING btree (id);

CREATE UNIQUE INDEX chat_messages_pkey ON public.chat_messages USING btree (id);

CREATE UNIQUE INDEX chat_participants_pkey ON public.chat_participants USING btree (room_id, user_id);

CREATE UNIQUE INDEX chat_room_invitations_pkey ON public.chat_room_invitations USING btree (id);

CREATE UNIQUE INDEX chat_room_invitations_room_id_invitee_id_status_key ON public.chat_room_invitations USING btree (room_id, invitee_id, status);

CREATE UNIQUE INDEX chat_rooms_pkey ON public.chat_rooms USING btree (id);

CREATE UNIQUE INDEX collaboration_applications_pkey ON public.collaboration_applications USING btree (id);

CREATE UNIQUE INDEX collaboration_invitations_pkey ON public.collaboration_invitations USING btree (id);

CREATE UNIQUE INDEX collaboration_members_pkey ON public.collaboration_members USING btree (id);

CREATE UNIQUE INDEX collaboration_stats_pkey ON public.collaboration_stats USING btree (collaboration_id);

CREATE UNIQUE INDEX collaborations_pkey ON public.collaborations USING btree (id);

CREATE UNIQUE INDEX homepage_slider_images_pkey ON public.homepage_slider_images USING btree (id);

CREATE UNIQUE INDEX homepage_trending_projects_pkey ON public.homepage_trending_projects USING btree (id);

CREATE INDEX idx_activity_field_keywords_field ON public.activity_field_keywords USING btree (activity_field);

CREATE INDEX idx_activity_field_keywords_keyword ON public.activity_field_keywords USING btree (keyword);

CREATE INDEX idx_admin_activity_logs_action ON public.admin_activity_logs USING btree (action);

CREATE INDEX idx_admin_activity_logs_created_at ON public.admin_activity_logs USING btree (created_at);

CREATE INDEX idx_admins_email ON public.admins USING btree (email);

CREATE INDEX idx_applications_applicant ON public.project_applications USING btree (applicant_id);

CREATE INDEX idx_applications_applied_date ON public.project_applications USING btree (applied_date DESC);

CREATE INDEX idx_applications_project ON public.project_applications USING btree (project_id);

CREATE INDEX idx_applications_shortlisted ON public.project_applications USING btree (project_id, is_shortlisted) WHERE (is_shortlisted = true);

CREATE INDEX idx_applications_status ON public.project_applications USING btree (status);

CREATE INDEX idx_applications_unread ON public.project_applications USING btree (project_id, is_read) WHERE (is_read = false);

CREATE INDEX idx_chat_messages_type ON public.chat_messages USING btree (type);

CREATE INDEX idx_chat_participants_role ON public.chat_participants USING btree (room_id, role);

CREATE INDEX idx_chat_room_invitations_invitee_id ON public.chat_room_invitations USING btree (invitee_id);

CREATE INDEX idx_chat_room_invitations_invitee_pending ON public.chat_room_invitations USING btree (invitee_id) WHERE (status = 'pending'::text);

CREATE INDEX idx_chat_room_invitations_room_id ON public.chat_room_invitations USING btree (room_id);

CREATE INDEX idx_chat_room_invitations_status ON public.chat_room_invitations USING btree (status);

CREATE INDEX idx_chat_rooms_collaboration_id ON public.chat_rooms USING btree (collaboration_id) WHERE (collaboration_id IS NOT NULL);

CREATE INDEX idx_chat_rooms_notice_message_id ON public.chat_rooms USING btree (notice_message_id);

CREATE INDEX idx_chat_rooms_project_id ON public.chat_rooms USING btree (project_id) WHERE (project_id IS NOT NULL);

CREATE INDEX idx_collab_members_active ON public.collaboration_members USING btree (collaboration_id, status) WHERE (status = 'active'::text);

CREATE INDEX idx_collab_members_collaboration ON public.collaboration_members USING btree (collaboration_id);

CREATE INDEX idx_collab_members_user ON public.collaboration_members USING btree (user_id);

CREATE INDEX idx_collaboration_applications_applicant ON public.collaboration_applications USING btree (applicant_id);

CREATE INDEX idx_collaboration_applications_applied_date ON public.collaboration_applications USING btree (applied_date DESC);

CREATE INDEX idx_collaboration_applications_collaboration ON public.collaboration_applications USING btree (collaboration_id);

CREATE INDEX idx_collaboration_applications_hidden_applicant ON public.collaboration_applications USING btree (applicant_id, is_hidden_by_applicant) WHERE (is_hidden_by_applicant = true);

CREATE INDEX idx_collaboration_applications_shortlisted ON public.collaboration_applications USING btree (collaboration_id, is_shortlisted) WHERE (is_shortlisted = true);

CREATE INDEX idx_collaboration_applications_status ON public.collaboration_applications USING btree (status);

CREATE INDEX idx_collaboration_applications_unread ON public.collaboration_applications USING btree (collaboration_id, is_read) WHERE (is_read = false);

CREATE INDEX idx_collaboration_invitations_hidden_invitee ON public.collaboration_invitations USING btree (invitee_id, is_hidden_by_invitee) WHERE (is_hidden_by_invitee = true);

CREATE INDEX idx_collaboration_invitations_hidden_inviter ON public.collaboration_invitations USING btree (inviter_id, is_hidden_by_inviter) WHERE (is_hidden_by_inviter = true);

CREATE INDEX idx_collaboration_stats_bookmark_count ON public.collaboration_stats USING btree (bookmark_count DESC);

CREATE INDEX idx_collaboration_stats_last_viewed ON public.collaboration_stats USING btree (last_viewed_at DESC);

CREATE INDEX idx_collaboration_stats_view_count ON public.collaboration_stats USING btree (view_count DESC);

CREATE INDEX idx_collaborations_category ON public.collaborations USING btree (category);

CREATE INDEX idx_collaborations_category_created_at ON public.collaborations USING btree (category, created_at DESC);

CREATE INDEX idx_collaborations_category_status_created_at ON public.collaborations USING btree (category, status, created_at DESC);

CREATE INDEX idx_collaborations_created ON public.collaborations USING btree (created_at DESC);

CREATE INDEX idx_collaborations_created_at ON public.collaborations USING btree (created_at DESC);

CREATE INDEX idx_collaborations_created_by ON public.collaborations USING btree (created_by);

CREATE INDEX idx_collaborations_creator ON public.collaborations USING btree (created_by);

CREATE INDEX idx_collaborations_featured ON public.collaborations USING btree (is_featured) WHERE (is_featured = true);

CREATE INDEX idx_collaborations_search ON public.collaborations USING gin (to_tsvector('simple'::regconfig, ((title || ' '::text) || description)));

CREATE INDEX idx_collaborations_status ON public.collaborations USING btree (status);

CREATE INDEX idx_collaborations_status_created_at ON public.collaborations USING btree (status, created_at DESC);

CREATE INDEX idx_collaborations_tags ON public.collaborations USING gin (tags);

CREATE INDEX idx_collaborations_type ON public.collaborations USING btree (collaboration_type);

CREATE INDEX idx_comments_active ON public.project_comments USING btree (project_id) WHERE (is_deleted = false);

CREATE INDEX idx_comments_parent ON public.project_comments USING btree (parent_id);

CREATE INDEX idx_comments_project ON public.project_comments USING btree (project_id, created_at DESC);

CREATE INDEX idx_comments_user ON public.project_comments USING btree (user_id);

CREATE INDEX idx_homepage_slider_images_active ON public.homepage_slider_images USING btree (is_active);

CREATE INDEX idx_homepage_slider_images_order ON public.homepage_slider_images USING btree (display_order);

CREATE INDEX idx_homepage_trending_projects_active ON public.homepage_trending_projects USING btree (is_active);

CREATE INDEX idx_homepage_trending_projects_order ON public.homepage_trending_projects USING btree (display_order);

CREATE INDEX idx_inquiries_created_at ON public.inquiries USING btree (created_at);

CREATE INDEX idx_inquiries_status ON public.inquiries USING btree (status);

CREATE INDEX idx_inquiries_user_id ON public.inquiries USING btree (user_id);

CREATE INDEX idx_invitations_collaboration ON public.collaboration_invitations USING btree (collaboration_id);

CREATE INDEX idx_invitations_invitee ON public.collaboration_invitations USING btree (invitee_id);

CREATE INDEX idx_invitations_inviter ON public.collaboration_invitations USING btree (inviter_id);

CREATE INDEX idx_invitations_sent_date ON public.collaboration_invitations USING btree (sent_date DESC);

CREATE INDEX idx_invitations_status ON public.collaboration_invitations USING btree (status);

CREATE INDEX idx_invitations_unread ON public.collaboration_invitations USING btree (invitee_id, is_read) WHERE (is_read = false);

CREATE INDEX idx_lounge_comment_likes_comment ON public.lounge_comment_likes USING btree (comment_id);

CREATE INDEX idx_lounge_comment_likes_user ON public.lounge_comment_likes USING btree (user_id);

CREATE INDEX idx_lounge_comments_author ON public.lounge_comments USING btree (author_id);

CREATE INDEX idx_lounge_comments_collaboration ON public.lounge_comments USING btree (collaboration_id) WHERE (collaboration_id IS NOT NULL);

CREATE INDEX idx_lounge_comments_magazine ON public.lounge_comments USING btree (magazine_id) WHERE (magazine_id IS NOT NULL);

CREATE INDEX idx_lounge_comments_parent ON public.lounge_comments USING btree (parent_id, created_at DESC);

CREATE INDEX idx_lounge_comments_project ON public.lounge_comments USING btree (project_id) WHERE (project_id IS NOT NULL);

CREATE INDEX idx_lounge_likes_actor_role ON public.lounge_likes USING btree (actor_role) WHERE (actor_role IS NOT NULL);

CREATE INDEX idx_magazines_author ON public.magazines USING btree (author_id);

CREATE INDEX idx_magazines_category ON public.magazines USING btree (category);

CREATE INDEX idx_magazines_featured_order ON public.magazines USING btree (is_featured DESC, display_order) WHERE (is_featured = true);

CREATE INDEX idx_magazines_published ON public.magazines USING btree (published_at DESC) WHERE (status = 'published'::text);

CREATE INDEX idx_magazines_status ON public.magazines USING btree (status);

CREATE INDEX idx_partnership_inquiries_received_date ON public.partnership_inquiries USING btree (received_date DESC);

CREATE INDEX idx_partnership_inquiries_receiver ON public.partnership_inquiries USING btree (receiver_id);

CREATE INDEX idx_partnership_inquiries_sender ON public.partnership_inquiries USING btree (sender_id);

CREATE INDEX idx_partnership_inquiries_status ON public.partnership_inquiries USING btree (status);

CREATE INDEX idx_partnership_inquiries_unread ON public.partnership_inquiries USING btree (receiver_id, is_read) WHERE (is_read = false);

CREATE INDEX idx_profile_artists_activity_field ON public.profile_artists USING btree (activity_field);

CREATE INDEX idx_profile_artists_activity_field_created_at ON public.profile_artists USING btree (activity_field, created_at DESC);

CREATE INDEX idx_profile_artists_created_at ON public.profile_artists USING btree (created_at DESC) WHERE (is_active = true);

CREATE INDEX idx_profile_artists_verified ON public.profile_artists USING btree (is_verified) WHERE (is_verified = true);

CREATE INDEX idx_profile_brands_approval_status ON public.profile_brands USING btree (approval_status);

CREATE INDEX idx_profile_brands_created_at ON public.profile_brands USING btree (created_at DESC) WHERE ((is_active = true) AND (approval_status = 'approved'::text));

CREATE INDEX idx_profile_creatives_activity_field ON public.profile_creatives USING btree (activity_field);

CREATE INDEX idx_profile_creatives_activity_field_created_at ON public.profile_creatives USING btree (activity_field, created_at DESC);

CREATE INDEX idx_profile_creatives_verified ON public.profile_creatives USING btree (is_verified) WHERE (is_verified = true);

CREATE INDEX idx_profiles_banned_until ON public.profiles USING btree (banned_until);

CREATE INDEX idx_profiles_events_agreed ON public.profiles USING btree (events_agreed_at) WHERE (events_agreed_at IS NOT NULL);

CREATE INDEX idx_profiles_last_access ON public.profiles USING btree (last_access);

CREATE INDEX idx_profiles_marketing_agreed ON public.profiles USING btree (marketing_agreed_at) WHERE (marketing_agreed_at IS NOT NULL);

CREATE INDEX idx_profiles_online ON public.profiles USING btree (is_online) WHERE (is_online = true);

CREATE INDEX idx_profiles_partner_matching_agreed ON public.profiles USING btree (partner_matching_agreed_at) WHERE (partner_matching_agreed_at IS NOT NULL);

CREATE INDEX idx_profiles_project_recommendation_agreed ON public.profiles USING btree (project_recommendation_agreed_at) WHERE (project_recommendation_agreed_at IS NOT NULL);

CREATE INDEX idx_project_applications_hidden_applicant ON public.project_applications USING btree (applicant_id, is_hidden_by_applicant) WHERE (is_hidden_by_applicant = true);

CREATE INDEX idx_project_members_active ON public.project_members USING btree (project_id, status) WHERE (status = 'active'::text);

CREATE INDEX idx_project_members_project ON public.project_members USING btree (project_id);

CREATE INDEX idx_project_members_user ON public.project_members USING btree (user_id);

CREATE INDEX idx_project_proposals_hidden_receiver ON public.project_proposals USING btree (receiver_id, is_hidden_by_receiver) WHERE (is_hidden_by_receiver = true);

CREATE INDEX idx_project_proposals_hidden_sender ON public.project_proposals USING btree (sender_id, is_hidden_by_sender) WHERE (is_hidden_by_sender = true);

CREATE INDEX idx_project_stats_bookmark_count ON public.project_stats USING btree (bookmark_count DESC);

CREATE INDEX idx_project_stats_last_viewed ON public.project_stats USING btree (last_viewed_at DESC);

CREATE INDEX idx_project_stats_view_count ON public.project_stats USING btree (view_count DESC);

CREATE INDEX idx_projects_category ON public.projects USING btree (category);

CREATE INDEX idx_projects_category_created_at ON public.projects USING btree (category, created_at DESC);

CREATE INDEX idx_projects_category_status_created_at ON public.projects USING btree (category, status, created_at DESC);

CREATE INDEX idx_projects_created ON public.projects USING btree (created_at DESC);

CREATE INDEX idx_projects_created_at ON public.projects USING btree (created_at DESC);

CREATE INDEX idx_projects_created_by ON public.projects USING btree (created_by);

CREATE INDEX idx_projects_creator ON public.projects USING btree (created_by);

CREATE INDEX idx_projects_deadline ON public.projects USING btree (deadline);

CREATE INDEX idx_projects_featured ON public.projects USING btree (is_featured) WHERE (is_featured = true);

CREATE INDEX idx_projects_is_trending_display_order ON public.projects USING btree (is_trending DESC, display_order, created_at DESC);

CREATE INDEX idx_projects_search ON public.projects USING gin (to_tsvector('simple'::regconfig, ((title || ' '::text) || description)));

CREATE INDEX idx_projects_status ON public.projects USING btree (status);

CREATE INDEX idx_projects_status_created_at ON public.projects USING btree (status, created_at DESC);

CREATE INDEX idx_projects_tags ON public.projects USING gin (tags);

CREATE INDEX idx_proposals_project ON public.project_proposals USING btree (project_id);

CREATE INDEX idx_proposals_receiver ON public.project_proposals USING btree (receiver_id);

CREATE INDEX idx_proposals_sender ON public.project_proposals USING btree (sender_id);

CREATE INDEX idx_proposals_sent_date ON public.project_proposals USING btree (sent_date DESC);

CREATE INDEX idx_proposals_status ON public.project_proposals USING btree (status);

CREATE INDEX idx_proposals_unread ON public.project_proposals USING btree (receiver_id, is_read) WHERE (is_read = false);

CREATE INDEX idx_reviews_collaboration_id ON public.reviews USING btree (collaboration_id) WHERE (collaboration_id IS NOT NULL);

CREATE INDEX idx_reviews_created_at ON public.reviews USING btree (created_at DESC);

CREATE INDEX idx_reviews_project_id ON public.reviews USING btree (project_id) WHERE (project_id IS NOT NULL);

CREATE INDEX idx_reviews_rating ON public.reviews USING btree (rating);

CREATE INDEX idx_reviews_reviewee_id ON public.reviews USING btree (reviewee_id);

CREATE INDEX idx_reviews_reviewer_id ON public.reviews USING btree (reviewer_id);

CREATE INDEX idx_reviews_visible ON public.reviews USING btree (is_visible) WHERE (is_visible = true);

CREATE INDEX idx_search_history_created ON public.search_history USING btree (created_at DESC);

CREATE INDEX idx_search_history_query ON public.search_history USING btree (query);

CREATE INDEX idx_search_history_user_created ON public.search_history USING btree (user_id, created_at DESC);

CREATE INDEX idx_server_notifications_active ON public.server_notifications USING btree (is_active);

CREATE INDEX idx_server_notifications_app_max_version ON public.server_notifications USING btree (app_max_version);

CREATE INDEX idx_server_notifications_app_min_version ON public.server_notifications USING btree (app_min_version);

CREATE INDEX idx_server_notifications_audiences ON public.server_notifications USING gin (audiences);

CREATE INDEX idx_server_notifications_ends_at ON public.server_notifications USING btree (ends_at);

CREATE INDEX idx_server_notifications_priority ON public.server_notifications USING btree (priority DESC);

CREATE INDEX idx_server_notifications_starts_at ON public.server_notifications USING btree (starts_at);

CREATE INDEX idx_server_notifications_type ON public.server_notifications USING btree (type);

CREATE INDEX idx_user_bookmarks_collaboration ON public.user_bookmarks USING btree (collaboration_id) WHERE (collaboration_id IS NOT NULL);

CREATE INDEX idx_user_bookmarks_project ON public.user_bookmarks USING btree (project_id) WHERE (project_id IS NOT NULL);

CREATE INDEX idx_user_bookmarks_user ON public.user_bookmarks USING btree (user_id);

CREATE INDEX idx_user_collab_pref_collaboration ON public.user_collaboration_preferences USING btree (collaboration_id);

CREATE INDEX idx_user_collab_pref_profile_status ON public.user_collaboration_preferences USING btree (profile_id, status);

CREATE INDEX idx_user_notifications_receiver ON public.user_notifications USING btree (receiver_id, created_at DESC);

CREATE INDEX idx_user_notifications_unread ON public.user_notifications USING btree (receiver_id) WHERE (is_read = false);

CREATE INDEX idx_user_partner_pref_partner ON public.user_partner_preferences USING btree (partner_id);

CREATE INDEX idx_user_partner_pref_profile_status ON public.user_partner_preferences USING btree (profile_id, status);

CREATE INDEX idx_user_project_pref_profile_status ON public.user_project_preferences USING btree (profile_id, status);

CREATE INDEX idx_user_project_pref_project ON public.user_project_preferences USING btree (project_id);

CREATE UNIQUE INDEX inquiries_pkey ON public.inquiries USING btree (inquiry_id);

CREATE INDEX ix_profile_artists_user_active ON public.profile_artists USING btree (profile_id, is_active);

CREATE INDEX ix_profile_brands_user_active ON public.profile_brands USING btree (profile_id, is_active);

CREATE INDEX ix_profile_creatives_user_active ON public.profile_creatives USING btree (profile_id, is_active);

CREATE INDEX ix_profile_fans_user_active ON public.profile_fans USING btree (profile_id, is_active);

CREATE UNIQUE INDEX lounge_bookmarks_pkey ON public.lounge_bookmarks USING btree (id);

CREATE UNIQUE INDEX lounge_comment_likes_pkey ON public.lounge_comment_likes USING btree (id);

CREATE UNIQUE INDEX lounge_comment_likes_unique ON public.lounge_comment_likes USING btree (comment_id, user_id);

CREATE UNIQUE INDEX lounge_comments_pkey ON public.lounge_comments USING btree (id);

CREATE UNIQUE INDEX lounge_likes_pkey ON public.lounge_likes USING btree (id);

CREATE UNIQUE INDEX magazines_pkey ON public.magazines USING btree (id);

CREATE UNIQUE INDEX magazines_slug_key ON public.magazines USING btree (slug);

CREATE UNIQUE INDEX partner_stats_pkey ON public.partner_stats USING btree (profile_id);

CREATE UNIQUE INDEX partnership_inquiries_pkey ON public.partnership_inquiries USING btree (id);

CREATE UNIQUE INDEX profile_artist_pkey ON public.profile_artists USING btree (profile_id);

CREATE UNIQUE INDEX profile_brand_pkey ON public.profile_brands USING btree (profile_id);

CREATE UNIQUE INDEX profile_creative_nickname_key ON public.profile_creatives USING btree (nickname);

CREATE UNIQUE INDEX profile_creative_pkey ON public.profile_creatives USING btree (profile_id);

CREATE UNIQUE INDEX profile_fan_pkey ON public.profile_fans USING btree (profile_id);

CREATE UNIQUE INDEX profiles_email_key ON public.profiles USING btree (email);

CREATE UNIQUE INDEX profiles_nickname_key ON public.profiles USING btree (nickname);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX project_applications_pkey ON public.project_applications USING btree (id);

CREATE UNIQUE INDEX project_comments_pkey ON public.project_comments USING btree (id);

CREATE UNIQUE INDEX project_members_pkey ON public.project_members USING btree (id);

CREATE UNIQUE INDEX project_proposals_pkey ON public.project_proposals USING btree (id);

CREATE UNIQUE INDEX project_stats_pkey ON public.project_stats USING btree (project_id);

CREATE UNIQUE INDEX projects_pkey ON public.projects USING btree (id);

CREATE UNIQUE INDEX reviews_pkey ON public.reviews USING btree (id);

CREATE UNIQUE INDEX search_history_pkey ON public.search_history USING btree (id);

CREATE UNIQUE INDEX server_notifications_pkey ON public.server_notifications USING btree (id);

CREATE UNIQUE INDEX unique_application ON public.project_applications USING btree (project_id, applicant_id);

CREATE UNIQUE INDEX unique_collab_member ON public.collaboration_members USING btree (collaboration_id, user_id);

CREATE UNIQUE INDEX unique_collaboration_application ON public.collaboration_applications USING btree (collaboration_id, applicant_id);

CREATE UNIQUE INDEX unique_collaboration_bookmark ON public.lounge_bookmarks USING btree (user_id, collaboration_id);

CREATE UNIQUE INDEX unique_collaboration_like ON public.lounge_likes USING btree (user_id, collaboration_id);

CREATE UNIQUE INDEX unique_collaboration_review ON public.reviews USING btree (collaboration_id, reviewer_id, reviewee_id);

CREATE UNIQUE INDEX unique_comment_like ON public.lounge_likes USING btree (user_id, comment_id);

CREATE UNIQUE INDEX unique_invitation ON public.collaboration_invitations USING btree (collaboration_id, invitee_id);

CREATE UNIQUE INDEX unique_magazine_bookmark ON public.lounge_bookmarks USING btree (user_id, magazine_id);

CREATE UNIQUE INDEX unique_magazine_like ON public.lounge_likes USING btree (user_id, magazine_id);

CREATE UNIQUE INDEX unique_member ON public.project_members USING btree (project_id, user_id);

CREATE UNIQUE INDEX unique_project_bookmark ON public.lounge_bookmarks USING btree (user_id, project_id);

CREATE UNIQUE INDEX unique_project_like ON public.lounge_likes USING btree (user_id, project_id);

CREATE UNIQUE INDEX unique_project_review ON public.reviews USING btree (project_id, reviewer_id, reviewee_id);

CREATE UNIQUE INDEX unique_proposal ON public.project_proposals USING btree (project_id, receiver_id);

CREATE UNIQUE INDEX unique_user_collaboration_bookmark ON public.user_bookmarks USING btree (user_id, collaboration_id);

CREATE UNIQUE INDEX unique_user_project_bookmark ON public.user_bookmarks USING btree (user_id, project_id);

CREATE UNIQUE INDEX user_badges_pkey ON public.user_badges USING btree (user_id, badge_id);

CREATE UNIQUE INDEX user_bookmarks_pkey ON public.user_bookmarks USING btree (id);

CREATE UNIQUE INDEX user_collaboration_preferences_pkey ON public.user_collaboration_preferences USING btree (profile_id, collaboration_id);

CREATE UNIQUE INDEX user_notification_settings_pkey ON public.user_notification_settings USING btree (user_id, notification_type);

CREATE UNIQUE INDEX user_notifications_pkey ON public.user_notifications USING btree (id);

CREATE UNIQUE INDEX user_partner_preferences_pkey ON public.user_partner_preferences USING btree (profile_id, partner_id);

CREATE UNIQUE INDEX user_project_preferences_pkey ON public.user_project_preferences USING btree (profile_id, project_id);

CREATE UNIQUE INDEX user_push_tokens_pkey ON public.user_push_tokens USING btree (id);

CREATE UNIQUE INDEX user_push_tokens_user_id_token_key ON public.user_push_tokens USING btree (user_id, token);

CREATE UNIQUE INDEX user_user_preferences_pkey ON public.user_user_preferences USING btree (user_id, target_id, preference_type, target_type);

CREATE UNIQUE INDEX ux_profile_fans_user_active ON public.profile_fans USING btree (profile_id) WHERE (is_active = true);

alter table "public"."activity_field_keywords" add constraint "activity_field_keywords_pkey" PRIMARY KEY using index "activity_field_keywords_pkey";

alter table "public"."admin_activity_logs" add constraint "admin_activity_logs_pkey" PRIMARY KEY using index "admin_activity_logs_pkey";

alter table "public"."admins" add constraint "admins_pkey" PRIMARY KEY using index "admins_pkey";

alter table "public"."badges" add constraint "badges_pkey" PRIMARY KEY using index "badges_pkey";

alter table "public"."chat_messages" add constraint "chat_messages_pkey" PRIMARY KEY using index "chat_messages_pkey";

alter table "public"."chat_participants" add constraint "chat_participants_pkey" PRIMARY KEY using index "chat_participants_pkey";

alter table "public"."chat_room_invitations" add constraint "chat_room_invitations_pkey" PRIMARY KEY using index "chat_room_invitations_pkey";

alter table "public"."chat_rooms" add constraint "chat_rooms_pkey" PRIMARY KEY using index "chat_rooms_pkey";

alter table "public"."collaboration_applications" add constraint "collaboration_applications_pkey" PRIMARY KEY using index "collaboration_applications_pkey";

alter table "public"."collaboration_invitations" add constraint "collaboration_invitations_pkey" PRIMARY KEY using index "collaboration_invitations_pkey";

alter table "public"."collaboration_members" add constraint "collaboration_members_pkey" PRIMARY KEY using index "collaboration_members_pkey";

alter table "public"."collaboration_stats" add constraint "collaboration_stats_pkey" PRIMARY KEY using index "collaboration_stats_pkey";

alter table "public"."collaborations" add constraint "collaborations_pkey" PRIMARY KEY using index "collaborations_pkey";

alter table "public"."homepage_slider_images" add constraint "homepage_slider_images_pkey" PRIMARY KEY using index "homepage_slider_images_pkey";

alter table "public"."homepage_trending_projects" add constraint "homepage_trending_projects_pkey" PRIMARY KEY using index "homepage_trending_projects_pkey";

alter table "public"."inquiries" add constraint "inquiries_pkey" PRIMARY KEY using index "inquiries_pkey";

alter table "public"."lounge_bookmarks" add constraint "lounge_bookmarks_pkey" PRIMARY KEY using index "lounge_bookmarks_pkey";

alter table "public"."lounge_comment_likes" add constraint "lounge_comment_likes_pkey" PRIMARY KEY using index "lounge_comment_likes_pkey";

alter table "public"."lounge_comments" add constraint "lounge_comments_pkey" PRIMARY KEY using index "lounge_comments_pkey";

alter table "public"."lounge_likes" add constraint "lounge_likes_pkey" PRIMARY KEY using index "lounge_likes_pkey";

alter table "public"."magazines" add constraint "magazines_pkey" PRIMARY KEY using index "magazines_pkey";

alter table "public"."partner_stats" add constraint "partner_stats_pkey" PRIMARY KEY using index "partner_stats_pkey";

alter table "public"."partnership_inquiries" add constraint "partnership_inquiries_pkey" PRIMARY KEY using index "partnership_inquiries_pkey";

alter table "public"."profile_artists" add constraint "profile_artist_pkey" PRIMARY KEY using index "profile_artist_pkey";

alter table "public"."profile_brands" add constraint "profile_brand_pkey" PRIMARY KEY using index "profile_brand_pkey";

alter table "public"."profile_creatives" add constraint "profile_creative_pkey" PRIMARY KEY using index "profile_creative_pkey";

alter table "public"."profile_fans" add constraint "profile_fan_pkey" PRIMARY KEY using index "profile_fan_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."project_applications" add constraint "project_applications_pkey" PRIMARY KEY using index "project_applications_pkey";

alter table "public"."project_comments" add constraint "project_comments_pkey" PRIMARY KEY using index "project_comments_pkey";

alter table "public"."project_members" add constraint "project_members_pkey" PRIMARY KEY using index "project_members_pkey";

alter table "public"."project_proposals" add constraint "project_proposals_pkey" PRIMARY KEY using index "project_proposals_pkey";

alter table "public"."project_stats" add constraint "project_stats_pkey" PRIMARY KEY using index "project_stats_pkey";

alter table "public"."projects" add constraint "projects_pkey" PRIMARY KEY using index "projects_pkey";

alter table "public"."reviews" add constraint "reviews_pkey" PRIMARY KEY using index "reviews_pkey";

alter table "public"."search_history" add constraint "search_history_pkey" PRIMARY KEY using index "search_history_pkey";

alter table "public"."server_notifications" add constraint "server_notifications_pkey" PRIMARY KEY using index "server_notifications_pkey";

alter table "public"."user_badges" add constraint "user_badges_pkey" PRIMARY KEY using index "user_badges_pkey";

alter table "public"."user_bookmarks" add constraint "user_bookmarks_pkey" PRIMARY KEY using index "user_bookmarks_pkey";

alter table "public"."user_collaboration_preferences" add constraint "user_collaboration_preferences_pkey" PRIMARY KEY using index "user_collaboration_preferences_pkey";

alter table "public"."user_notification_settings" add constraint "user_notification_settings_pkey" PRIMARY KEY using index "user_notification_settings_pkey";

alter table "public"."user_notifications" add constraint "user_notifications_pkey" PRIMARY KEY using index "user_notifications_pkey";

alter table "public"."user_partner_preferences" add constraint "user_partner_preferences_pkey" PRIMARY KEY using index "user_partner_preferences_pkey";

alter table "public"."user_project_preferences" add constraint "user_project_preferences_pkey" PRIMARY KEY using index "user_project_preferences_pkey";

alter table "public"."user_push_tokens" add constraint "user_push_tokens_pkey" PRIMARY KEY using index "user_push_tokens_pkey";

alter table "public"."user_user_preferences" add constraint "user_user_preferences_pkey" PRIMARY KEY using index "user_user_preferences_pkey";

alter table "public"."activity_field_keywords" add constraint "activity_field_keywords_activity_field_keyword_uniq" UNIQUE using index "activity_field_keywords_activity_field_keyword_uniq";

alter table "public"."admin_activity_logs" add constraint "admin_activity_logs_admin_profile_id_fkey" FOREIGN KEY (admin_profile_id) REFERENCES public.admins(profile_id) ON DELETE CASCADE not valid;

alter table "public"."admin_activity_logs" validate constraint "admin_activity_logs_admin_profile_id_fkey";

alter table "public"."admin_activity_logs" add constraint "admin_activity_logs_target_admin_profile_id_fkey" FOREIGN KEY (target_admin_profile_id) REFERENCES public.admins(profile_id) ON DELETE SET NULL not valid;

alter table "public"."admin_activity_logs" validate constraint "admin_activity_logs_target_admin_profile_id_fkey";

alter table "public"."admins" add constraint "admins_email_key" UNIQUE using index "admins_email_key";

alter table "public"."admins" add constraint "admins_profile_id_profiles_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."admins" validate constraint "admins_profile_id_profiles_fkey";

alter table "public"."admins" add constraint "admins_role_check" CHECK ((role = ANY (ARRAY['admin'::text, 'super_admin'::text]))) not valid;

alter table "public"."admins" validate constraint "admins_role_check";

alter table "public"."badges" add constraint "badges_name_key" UNIQUE using index "badges_name_key";

alter table "public"."chat_messages" add constraint "chat_messages_room_id_fkey" FOREIGN KEY (room_id) REFERENCES public.chat_rooms(id) ON DELETE CASCADE not valid;

alter table "public"."chat_messages" validate constraint "chat_messages_room_id_fkey";

alter table "public"."chat_messages" add constraint "chat_messages_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."chat_messages" validate constraint "chat_messages_sender_id_fkey";

alter table "public"."chat_participants" add constraint "chat_participants_room_id_fkey" FOREIGN KEY (room_id) REFERENCES public.chat_rooms(id) ON DELETE CASCADE not valid;

alter table "public"."chat_participants" validate constraint "chat_participants_room_id_fkey";

alter table "public"."chat_participants" add constraint "chat_participants_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."chat_participants" validate constraint "chat_participants_user_id_fkey";

alter table "public"."chat_room_invitations" add constraint "chat_room_invitations_invitee_id_fkey" FOREIGN KEY (invitee_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."chat_room_invitations" validate constraint "chat_room_invitations_invitee_id_fkey";

alter table "public"."chat_room_invitations" add constraint "chat_room_invitations_inviter_id_fkey" FOREIGN KEY (inviter_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."chat_room_invitations" validate constraint "chat_room_invitations_inviter_id_fkey";

alter table "public"."chat_room_invitations" add constraint "chat_room_invitations_room_id_fkey" FOREIGN KEY (room_id) REFERENCES public.chat_rooms(id) ON DELETE CASCADE not valid;

alter table "public"."chat_room_invitations" validate constraint "chat_room_invitations_room_id_fkey";

alter table "public"."chat_room_invitations" add constraint "chat_room_invitations_room_id_invitee_id_status_key" UNIQUE using index "chat_room_invitations_room_id_invitee_id_status_key";

alter table "public"."chat_room_invitations" add constraint "chat_room_invitations_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'rejected'::text, 'expired'::text, 'withdrawn'::text]))) not valid;

alter table "public"."chat_room_invitations" validate constraint "chat_room_invitations_status_check";

alter table "public"."chat_rooms" add constraint "chat_rooms_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE SET NULL not valid;

alter table "public"."chat_rooms" validate constraint "chat_rooms_collaboration_id_fkey";

alter table "public"."chat_rooms" add constraint "chat_rooms_created_by_fkey" FOREIGN KEY (created_by) REFERENCES auth.users(id) not valid;

alter table "public"."chat_rooms" validate constraint "chat_rooms_created_by_fkey";

alter table "public"."chat_rooms" add constraint "chat_rooms_notice_message_id_fkey" FOREIGN KEY (notice_message_id) REFERENCES public.chat_messages(id) ON DELETE SET NULL not valid;

alter table "public"."chat_rooms" validate constraint "chat_rooms_notice_message_id_fkey";

alter table "public"."chat_rooms" add constraint "chat_rooms_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE SET NULL not valid;

alter table "public"."chat_rooms" validate constraint "chat_rooms_project_id_fkey";

alter table "public"."chat_rooms" add constraint "chat_rooms_type_check" CHECK ((type = ANY (ARRAY['project'::text, 'collaboration'::text, 'team'::text, 'partner'::text]))) not valid;

alter table "public"."chat_rooms" validate constraint "chat_rooms_type_check";

alter table "public"."collaboration_applications" add constraint "collaboration_applications_applicant_id_fkey" FOREIGN KEY (applicant_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."collaboration_applications" validate constraint "collaboration_applications_applicant_id_fkey";

alter table "public"."collaboration_applications" add constraint "collaboration_applications_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."collaboration_applications" validate constraint "collaboration_applications_collaboration_id_fkey";

alter table "public"."collaboration_applications" add constraint "collaboration_applications_reviewer_id_fkey" FOREIGN KEY (reviewer_id) REFERENCES public.profiles(id) not valid;

alter table "public"."collaboration_applications" validate constraint "collaboration_applications_reviewer_id_fkey";

alter table "public"."collaboration_applications" add constraint "unique_collaboration_application" UNIQUE using index "unique_collaboration_application";

alter table "public"."collaboration_applications" add constraint "valid_collaboration_application_status" CHECK ((status = ANY (ARRAY['pending'::text, 'reviewed'::text, 'shortlisted'::text, 'accepted'::text, 'rejected'::text, 'withdrawn'::text]))) not valid;

alter table "public"."collaboration_applications" validate constraint "valid_collaboration_application_status";

alter table "public"."collaboration_invitations" add constraint "collaboration_invitations_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."collaboration_invitations" validate constraint "collaboration_invitations_collaboration_id_fkey";

alter table "public"."collaboration_invitations" add constraint "collaboration_invitations_invitee_id_fkey" FOREIGN KEY (invitee_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."collaboration_invitations" validate constraint "collaboration_invitations_invitee_id_fkey";

alter table "public"."collaboration_invitations" add constraint "collaboration_invitations_inviter_id_fkey" FOREIGN KEY (inviter_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."collaboration_invitations" validate constraint "collaboration_invitations_inviter_id_fkey";

alter table "public"."collaboration_invitations" add constraint "different_users_invitation" CHECK ((inviter_id <> invitee_id)) not valid;

alter table "public"."collaboration_invitations" validate constraint "different_users_invitation";

alter table "public"."collaboration_invitations" add constraint "unique_invitation" UNIQUE using index "unique_invitation";

alter table "public"."collaboration_invitations" add constraint "valid_invitation_status" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'rejected'::text, 'expired'::text, 'withdrawn'::text]))) not valid;

alter table "public"."collaboration_invitations" validate constraint "valid_invitation_status";

alter table "public"."collaboration_members" add constraint "collaboration_members_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."collaboration_members" validate constraint "collaboration_members_collaboration_id_fkey";

alter table "public"."collaboration_members" add constraint "collaboration_members_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."collaboration_members" validate constraint "collaboration_members_user_id_fkey";

alter table "public"."collaboration_members" add constraint "unique_collab_member" UNIQUE using index "unique_collab_member";

alter table "public"."collaboration_members" add constraint "valid_collab_member_status" CHECK ((status = ANY (ARRAY['active'::text, 'inactive'::text, 'left'::text, 'removed'::text]))) not valid;

alter table "public"."collaboration_members" validate constraint "valid_collab_member_status";

alter table "public"."collaboration_members" add constraint "valid_collab_profit_share" CHECK (((profit_share IS NULL) OR ((profit_share >= (0)::numeric) AND (profit_share <= (100)::numeric)))) not valid;

alter table "public"."collaboration_members" validate constraint "valid_collab_profit_share";

alter table "public"."collaboration_stats" add constraint "collaboration_stats_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."collaboration_stats" validate constraint "collaboration_stats_collaboration_id_fkey";

alter table "public"."collaboration_stats" add constraint "positive_collab_bookmark_count" CHECK ((bookmark_count >= 0)) not valid;

alter table "public"."collaboration_stats" validate constraint "positive_collab_bookmark_count";

alter table "public"."collaboration_stats" add constraint "positive_collab_view_count" CHECK ((view_count >= 0)) not valid;

alter table "public"."collaboration_stats" validate constraint "positive_collab_view_count";

alter table "public"."collaborations" add constraint "collaborations_category_check" CHECK ((category = ANY (ARRAY['music'::text, 'fashion'::text, 'beauty'::text, 'contents'::text, 'market'::text, 'Investment'::text, 'liveShopping'::text, 'event'::text, 'ticket'::text, 'tech'::text, 'life'::text, 'healing'::text, 'art'::text, 'gonggu'::text, 'brand'::text, 'accessories'::text, 'performance'::text, 'exhibition'::text]))) not valid;

alter table "public"."collaborations" validate constraint "collaborations_category_check";

alter table "public"."collaborations" add constraint "collaborations_creator_id_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."collaborations" validate constraint "collaborations_creator_id_fkey";

alter table "public"."collaborations" add constraint "collaborations_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'open'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text, 'on_hold'::text]))) not valid;

alter table "public"."collaborations" validate constraint "collaborations_status_check";

alter table "public"."collaborations" add constraint "valid_collab_status" CHECK ((status = ANY (ARRAY['draft'::text, 'open'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text, 'on_hold'::text]))) not valid;

alter table "public"."collaborations" validate constraint "valid_collab_status";

alter table "public"."collaborations" add constraint "valid_collab_type" CHECK ((collaboration_type = ANY (ARRAY['long_term'::text, 'short_term'::text, 'project_based'::text]))) not valid;

alter table "public"."collaborations" validate constraint "valid_collab_type";

alter table "public"."collaborations" add constraint "valid_collab_visibility" CHECK ((visibility = ANY (ARRAY['public'::text, 'private'::text, 'invited_only'::text]))) not valid;

alter table "public"."collaborations" validate constraint "valid_collab_visibility";

alter table "public"."collaborations" add constraint "valid_collab_work_type" CHECK ((work_type = ANY (ARRAY['remote'::text, 'onsite'::text, 'hybrid'::text]))) not valid;

alter table "public"."collaborations" validate constraint "valid_collab_work_type";

alter table "public"."collaborations" add constraint "valid_team_size" CHECK (((current_team_size <= team_size) OR (team_size IS NULL))) not valid;

alter table "public"."collaborations" validate constraint "valid_team_size";

alter table "public"."homepage_slider_images" add constraint "homepage_slider_images_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.admins(profile_id) ON DELETE SET NULL not valid;

alter table "public"."homepage_slider_images" validate constraint "homepage_slider_images_created_by_fkey";

alter table "public"."homepage_slider_images" add constraint "homepage_slider_images_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.admins(profile_id) ON DELETE SET NULL not valid;

alter table "public"."homepage_slider_images" validate constraint "homepage_slider_images_updated_by_fkey";

alter table "public"."homepage_trending_projects" add constraint "homepage_trending_projects_created_by_fkey" FOREIGN KEY (created_by) REFERENCES public.admins(profile_id) ON DELETE SET NULL not valid;

alter table "public"."homepage_trending_projects" validate constraint "homepage_trending_projects_created_by_fkey";

alter table "public"."homepage_trending_projects" add constraint "homepage_trending_projects_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.admins(profile_id) ON DELETE SET NULL not valid;

alter table "public"."homepage_trending_projects" validate constraint "homepage_trending_projects_updated_by_fkey";

alter table "public"."inquiries" add constraint "inquiries_inquiry_type_check" CHECK ((inquiry_type = ANY (ARRAY['ban_appeal'::text, 'general'::text, 'technical'::text, 'payment'::text, 'project'::text, 'account'::text, 'bug'::text, 'other'::text]))) not valid;

alter table "public"."inquiries" validate constraint "inquiries_inquiry_type_check";

alter table "public"."inquiries" add constraint "inquiries_manager_profile_id_fkey" FOREIGN KEY (manager_profile_id) REFERENCES public.admins(profile_id) ON DELETE SET NULL not valid;

alter table "public"."inquiries" validate constraint "inquiries_manager_profile_id_fkey";

alter table "public"."inquiries" add constraint "inquiries_nickname_fkey" FOREIGN KEY (nickname) REFERENCES public.profiles(nickname) ON UPDATE CASCADE not valid;

alter table "public"."inquiries" validate constraint "inquiries_nickname_fkey";

alter table "public"."inquiries" add constraint "inquiries_status_check" CHECK ((status = ANY (ARRAY['pending'::text, 'in_progress'::text, 'resolved'::text, 'closed'::text]))) not valid;

alter table "public"."inquiries" validate constraint "inquiries_status_check";

alter table "public"."inquiries" add constraint "inquiries_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."inquiries" validate constraint "inquiries_user_id_fkey";

alter table "public"."lounge_bookmarks" add constraint "lounge_bookmarks_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_bookmarks" validate constraint "lounge_bookmarks_collaboration_id_fkey";

alter table "public"."lounge_bookmarks" add constraint "lounge_bookmarks_magazine_id_fkey" FOREIGN KEY (magazine_id) REFERENCES public.magazines(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_bookmarks" validate constraint "lounge_bookmarks_magazine_id_fkey";

alter table "public"."lounge_bookmarks" add constraint "lounge_bookmarks_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_bookmarks" validate constraint "lounge_bookmarks_project_id_fkey";

alter table "public"."lounge_bookmarks" add constraint "lounge_bookmarks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_bookmarks" validate constraint "lounge_bookmarks_user_id_fkey";

alter table "public"."lounge_bookmarks" add constraint "unique_collaboration_bookmark" UNIQUE using index "unique_collaboration_bookmark";

alter table "public"."lounge_bookmarks" add constraint "unique_magazine_bookmark" UNIQUE using index "unique_magazine_bookmark";

alter table "public"."lounge_bookmarks" add constraint "unique_project_bookmark" UNIQUE using index "unique_project_bookmark";

alter table "public"."lounge_bookmarks" add constraint "valid_lounge_bookmark_target" CHECK ((((project_id IS NOT NULL) AND (magazine_id IS NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (magazine_id IS NOT NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (magazine_id IS NULL) AND (collaboration_id IS NOT NULL)))) not valid;

alter table "public"."lounge_bookmarks" validate constraint "valid_lounge_bookmark_target";

alter table "public"."lounge_comment_likes" add constraint "lounge_comment_likes_comment_id_fkey" FOREIGN KEY (comment_id) REFERENCES public.lounge_comments(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_comment_likes" validate constraint "lounge_comment_likes_comment_id_fkey";

alter table "public"."lounge_comment_likes" add constraint "lounge_comment_likes_unique" UNIQUE using index "lounge_comment_likes_unique";

alter table "public"."lounge_comment_likes" add constraint "lounge_comment_likes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_comment_likes" validate constraint "lounge_comment_likes_user_id_fkey";

alter table "public"."lounge_comments" add constraint "lounge_comments_author_id_fkey" FOREIGN KEY (author_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_comments" validate constraint "lounge_comments_author_id_fkey";

alter table "public"."lounge_comments" add constraint "lounge_comments_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_comments" validate constraint "lounge_comments_collaboration_id_fkey";

alter table "public"."lounge_comments" add constraint "lounge_comments_content_check" CHECK (((length(content) > 0) AND (length(content) <= 5000))) not valid;

alter table "public"."lounge_comments" validate constraint "lounge_comments_content_check";

alter table "public"."lounge_comments" add constraint "lounge_comments_magazine_id_fkey" FOREIGN KEY (magazine_id) REFERENCES public.magazines(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_comments" validate constraint "lounge_comments_magazine_id_fkey";

alter table "public"."lounge_comments" add constraint "lounge_comments_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.lounge_comments(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_comments" validate constraint "lounge_comments_parent_id_fkey";

alter table "public"."lounge_comments" add constraint "lounge_comments_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_comments" validate constraint "lounge_comments_project_id_fkey";

alter table "public"."lounge_comments" add constraint "lounge_comments_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'hidden'::text, 'deleted'::text, 'blocked'::text]))) not valid;

alter table "public"."lounge_comments" validate constraint "lounge_comments_status_check";

alter table "public"."lounge_comments" add constraint "valid_lounge_comment_reference" CHECK ((((project_id IS NOT NULL) AND (magazine_id IS NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (magazine_id IS NOT NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (magazine_id IS NULL) AND (collaboration_id IS NOT NULL)))) not valid;

alter table "public"."lounge_comments" validate constraint "valid_lounge_comment_reference";

alter table "public"."lounge_likes" add constraint "chk_lounge_likes_actor_role" CHECK (((actor_role IS NULL) OR (actor_role = ANY (ARRAY['fan'::text, 'brand'::text, 'artist'::text, 'creative'::text])))) not valid;

alter table "public"."lounge_likes" validate constraint "chk_lounge_likes_actor_role";

alter table "public"."lounge_likes" add constraint "lounge_likes_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_likes" validate constraint "lounge_likes_collaboration_id_fkey";

alter table "public"."lounge_likes" add constraint "lounge_likes_comment_id_fkey" FOREIGN KEY (comment_id) REFERENCES public.lounge_comments(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_likes" validate constraint "lounge_likes_comment_id_fkey";

alter table "public"."lounge_likes" add constraint "lounge_likes_magazine_id_fkey" FOREIGN KEY (magazine_id) REFERENCES public.magazines(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_likes" validate constraint "lounge_likes_magazine_id_fkey";

alter table "public"."lounge_likes" add constraint "lounge_likes_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_likes" validate constraint "lounge_likes_project_id_fkey";

alter table "public"."lounge_likes" add constraint "lounge_likes_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."lounge_likes" validate constraint "lounge_likes_user_id_fkey";

alter table "public"."lounge_likes" add constraint "unique_collaboration_like" UNIQUE using index "unique_collaboration_like";

alter table "public"."lounge_likes" add constraint "unique_comment_like" UNIQUE using index "unique_comment_like";

alter table "public"."lounge_likes" add constraint "unique_magazine_like" UNIQUE using index "unique_magazine_like";

alter table "public"."lounge_likes" add constraint "unique_project_like" UNIQUE using index "unique_project_like";

alter table "public"."lounge_likes" add constraint "valid_lounge_like_target" CHECK ((((project_id IS NOT NULL) AND (magazine_id IS NULL) AND (comment_id IS NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (magazine_id IS NOT NULL) AND (comment_id IS NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (magazine_id IS NULL) AND (comment_id IS NOT NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (magazine_id IS NULL) AND (comment_id IS NULL) AND (collaboration_id IS NOT NULL)))) not valid;

alter table "public"."lounge_likes" validate constraint "valid_lounge_like_target";

alter table "public"."magazines" add constraint "magazines_author_id_fkey" FOREIGN KEY (author_id) REFERENCES public.profiles(id) ON DELETE SET NULL not valid;

alter table "public"."magazines" validate constraint "magazines_author_id_fkey";

alter table "public"."magazines" add constraint "magazines_category_check" CHECK ((category = ANY (ARRAY[''::text, ''::text, ''::text, ''::text, ''::text, ''::text, ''::text]))) not valid;

alter table "public"."magazines" validate constraint "magazines_category_check";

alter table "public"."magazines" add constraint "magazines_difficulty_level_check" CHECK ((difficulty_level = ANY (ARRAY['beginner'::text, 'intermediate'::text, 'advanced'::text]))) not valid;

alter table "public"."magazines" validate constraint "magazines_difficulty_level_check";

alter table "public"."magazines" add constraint "magazines_related_project_fkey" FOREIGN KEY (related_project) REFERENCES public.projects(id) not valid;

alter table "public"."magazines" validate constraint "magazines_related_project_fkey";

alter table "public"."magazines" add constraint "magazines_slug_key" UNIQUE using index "magazines_slug_key";

alter table "public"."magazines" add constraint "magazines_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'published'::text, 'archived'::text, 'deleted'::text]))) not valid;

alter table "public"."magazines" validate constraint "magazines_status_check";

alter table "public"."magazines" add constraint "magazines_updated_by_fkey" FOREIGN KEY (updated_by) REFERENCES public.profiles(id) not valid;

alter table "public"."magazines" validate constraint "magazines_updated_by_fkey";

alter table "public"."partner_stats" add constraint "partner_stats_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) not valid;

alter table "public"."partner_stats" validate constraint "partner_stats_profile_id_fkey";

alter table "public"."partnership_inquiries" add constraint "different_users_partnership_inquiry" CHECK ((sender_id <> receiver_id)) not valid;

alter table "public"."partnership_inquiries" validate constraint "different_users_partnership_inquiry";

alter table "public"."partnership_inquiries" add constraint "partnership_inquiries_receiver_id_fkey" FOREIGN KEY (receiver_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."partnership_inquiries" validate constraint "partnership_inquiries_receiver_id_fkey";

alter table "public"."partnership_inquiries" add constraint "partnership_inquiries_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."partnership_inquiries" validate constraint "partnership_inquiries_sender_id_fkey";

alter table "public"."partnership_inquiries" add constraint "valid_partnership_inquiry_status" CHECK ((status = ANY (ARRAY['pending'::text, 'accepted'::text, 'rejected'::text, 'on_hold'::text]))) not valid;

alter table "public"."partnership_inquiries" validate constraint "valid_partnership_inquiry_status";

alter table "public"."partnership_inquiries" add constraint "valid_partnership_response_action" CHECK (((response_action IS NULL) OR (response_action = ANY (ARRAY['accept'::text, 'reject'::text, 'hold'::text])))) not valid;

alter table "public"."partnership_inquiries" validate constraint "valid_partnership_response_action";

alter table "public"."profile_artists" add constraint "profile_artist_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."profile_artists" validate constraint "profile_artist_profile_id_fkey";

alter table "public"."profile_brands" add constraint "profile_brand_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."profile_brands" validate constraint "profile_brand_profile_id_fkey";

alter table "public"."profile_creatives" add constraint "profile_creative_nickname_key" UNIQUE using index "profile_creative_nickname_key";

alter table "public"."profile_creatives" add constraint "profile_creative_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."profile_creatives" validate constraint "profile_creative_profile_id_fkey";

alter table "public"."profile_creatives" add constraint "profile_creatives_nickname_check" CHECK ((char_length(nickname) <= 20)) not valid;

alter table "public"."profile_creatives" validate constraint "profile_creatives_nickname_check";

alter table "public"."profile_fans" add constraint "profile_fan_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."profile_fans" validate constraint "profile_fan_profile_id_fkey";

alter table "public"."profiles" add constraint "profiles_email_key" UNIQUE using index "profiles_email_key";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."profiles" add constraint "profiles_nickname_check" CHECK ((length(nickname) <= 20)) not valid;

alter table "public"."profiles" validate constraint "profiles_nickname_check";

alter table "public"."profiles" add constraint "profiles_nickname_key" UNIQUE using index "profiles_nickname_key";

alter table "public"."project_applications" add constraint "project_applications_applicant_id_fkey" FOREIGN KEY (applicant_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."project_applications" validate constraint "project_applications_applicant_id_fkey";

alter table "public"."project_applications" add constraint "project_applications_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_applications" validate constraint "project_applications_project_id_fkey";

alter table "public"."project_applications" add constraint "project_applications_reviewer_id_fkey" FOREIGN KEY (reviewer_id) REFERENCES public.profiles(id) not valid;

alter table "public"."project_applications" validate constraint "project_applications_reviewer_id_fkey";

alter table "public"."project_applications" add constraint "unique_application" UNIQUE using index "unique_application";

alter table "public"."project_applications" add constraint "valid_application_status" CHECK ((status = ANY (ARRAY['pending'::text, 'reviewed'::text, 'shortlisted'::text, 'accepted'::text, 'rejected'::text, 'withdrawn'::text]))) not valid;

alter table "public"."project_applications" validate constraint "valid_application_status";

alter table "public"."project_comments" add constraint "project_comments_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES public.project_comments(id) ON DELETE CASCADE not valid;

alter table "public"."project_comments" validate constraint "project_comments_parent_id_fkey";

alter table "public"."project_comments" add constraint "project_comments_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_comments" validate constraint "project_comments_project_id_fkey";

alter table "public"."project_comments" add constraint "project_comments_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."project_comments" validate constraint "project_comments_user_id_fkey";

alter table "public"."project_comments" add constraint "valid_content" CHECK (((length(content) > 0) AND (length(content) <= 5000))) not valid;

alter table "public"."project_comments" validate constraint "valid_content";

alter table "public"."project_members" add constraint "project_members_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_members" validate constraint "project_members_project_id_fkey";

alter table "public"."project_members" add constraint "project_members_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."project_members" validate constraint "project_members_user_id_fkey";

alter table "public"."project_members" add constraint "unique_member" UNIQUE using index "unique_member";

alter table "public"."project_members" add constraint "valid_member_status" CHECK ((status = ANY (ARRAY['active'::text, 'inactive'::text, 'left'::text, 'removed'::text]))) not valid;

alter table "public"."project_members" validate constraint "valid_member_status";

alter table "public"."project_proposals" add constraint "different_users" CHECK ((sender_id <> receiver_id)) not valid;

alter table "public"."project_proposals" validate constraint "different_users";

alter table "public"."project_proposals" add constraint "project_proposals_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_proposals" validate constraint "project_proposals_project_id_fkey";

alter table "public"."project_proposals" add constraint "project_proposals_receiver_id_fkey" FOREIGN KEY (receiver_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."project_proposals" validate constraint "project_proposals_receiver_id_fkey";

alter table "public"."project_proposals" add constraint "project_proposals_sender_id_fkey" FOREIGN KEY (sender_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."project_proposals" validate constraint "project_proposals_sender_id_fkey";

alter table "public"."project_proposals" add constraint "unique_proposal" UNIQUE using index "unique_proposal";

alter table "public"."project_proposals" add constraint "valid_proposal_status" CHECK ((status = ANY (ARRAY['pending'::text, 'viewed'::text, 'accepted'::text, 'rejected'::text, 'expired'::text, 'withdrawn'::text]))) not valid;

alter table "public"."project_proposals" validate constraint "valid_proposal_status";

alter table "public"."project_stats" add constraint "positive_bookmark_count" CHECK ((bookmark_count >= 0)) not valid;

alter table "public"."project_stats" validate constraint "positive_bookmark_count";

alter table "public"."project_stats" add constraint "positive_view_count" CHECK ((view_count >= 0)) not valid;

alter table "public"."project_stats" validate constraint "positive_view_count";

alter table "public"."project_stats" add constraint "project_stats_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."project_stats" validate constraint "project_stats_project_id_fkey";

alter table "public"."projects" add constraint "projects_category_check" CHECK ((category = ANY (ARRAY['music'::text, 'fashion'::text, 'beauty'::text, 'contents'::text, 'market'::text, 'Investment'::text, 'liveShopping'::text, 'event'::text, 'ticket'::text, 'tech'::text, 'life'::text, 'healing'::text]))) not valid;

alter table "public"."projects" validate constraint "projects_category_check";

alter table "public"."projects" add constraint "projects_creator_id_fkey" FOREIGN KEY (created_by) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."projects" validate constraint "projects_creator_id_fkey";

alter table "public"."projects" add constraint "projects_status_check" CHECK ((status = ANY (ARRAY['draft'::text, 'open'::text, 'in_progress'::text, 'completed'::text, 'cancelled'::text, 'on_hold'::text, 'deleted'::text]))) not valid;

alter table "public"."projects" validate constraint "projects_status_check";

alter table "public"."projects" add constraint "valid_budget" CHECK (((budget_max IS NULL) OR (budget_min IS NULL) OR (budget_max >= budget_min))) not valid;

alter table "public"."projects" validate constraint "valid_budget";

alter table "public"."projects" add constraint "valid_dates" CHECK (((scheduled_end_date IS NULL) OR (scheduled_start_date IS NULL) OR (scheduled_end_date >= scheduled_start_date))) not valid;

alter table "public"."projects" validate constraint "valid_dates";

alter table "public"."projects" add constraint "valid_visibility" CHECK ((visibility = ANY (ARRAY['public'::text, 'private'::text, 'invited_only'::text]))) not valid;

alter table "public"."projects" validate constraint "valid_visibility";

alter table "public"."projects" add constraint "valid_work_type" CHECK ((work_type = ANY (ARRAY['remote'::text, 'onsite'::text, 'hybrid'::text]))) not valid;

alter table "public"."projects" validate constraint "valid_work_type";

alter table "public"."reviews" add constraint "no_self_review" CHECK (((reviewer_id <> reviewee_id) OR (reviewee_id IS NULL))) not valid;

alter table "public"."reviews" validate constraint "no_self_review";

alter table "public"."reviews" add constraint "review_target_check" CHECK ((((project_id IS NOT NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (collaboration_id IS NOT NULL)))) not valid;

alter table "public"."reviews" validate constraint "review_target_check";

alter table "public"."reviews" add constraint "reviews_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."reviews" validate constraint "reviews_collaboration_id_fkey";

alter table "public"."reviews" add constraint "reviews_content_check" CHECK ((length(content) <= 2000)) not valid;

alter table "public"."reviews" validate constraint "reviews_content_check";

alter table "public"."reviews" add constraint "reviews_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."reviews" validate constraint "reviews_project_id_fkey";

alter table "public"."reviews" add constraint "reviews_rating_check" CHECK (((rating >= 0.5) AND (rating <= 5.0))) not valid;

alter table "public"."reviews" validate constraint "reviews_rating_check";

alter table "public"."reviews" add constraint "reviews_reviewee_id_fkey" FOREIGN KEY (reviewee_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."reviews" validate constraint "reviews_reviewee_id_fkey";

alter table "public"."reviews" add constraint "reviews_reviewer_id_fkey" FOREIGN KEY (reviewer_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."reviews" validate constraint "reviews_reviewer_id_fkey";

alter table "public"."reviews" add constraint "unique_collaboration_review" UNIQUE using index "unique_collaboration_review";

alter table "public"."reviews" add constraint "unique_project_review" UNIQUE using index "unique_project_review";

alter table "public"."search_history" add constraint "search_history_search_type_check" CHECK ((search_type = ANY (ARRAY['project'::text, 'partner'::text, 'collaboration'::text, 'all'::text]))) not valid;

alter table "public"."search_history" validate constraint "search_history_search_type_check";

alter table "public"."search_history" add constraint "search_history_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."search_history" validate constraint "search_history_user_id_fkey";

alter table "public"."server_notifications" add constraint "server_notifications_type_check" CHECK ((type = ANY (ARRAY['announcement'::text, 'version_update'::text, 'advertisement'::text, 'maintenance'::text]))) not valid;

alter table "public"."server_notifications" validate constraint "server_notifications_type_check";

alter table "public"."user_badges" add constraint "user_badges_badge_id_fkey" FOREIGN KEY (badge_id) REFERENCES public.badges(id) ON DELETE CASCADE not valid;

alter table "public"."user_badges" validate constraint "user_badges_badge_id_fkey";

alter table "public"."user_badges" add constraint "user_badges_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_badges" validate constraint "user_badges_user_id_fkey";

alter table "public"."user_bookmarks" add constraint "one_bookmark_type" CHECK ((((project_id IS NOT NULL) AND (collaboration_id IS NULL)) OR ((project_id IS NULL) AND (collaboration_id IS NOT NULL)))) not valid;

alter table "public"."user_bookmarks" validate constraint "one_bookmark_type";

alter table "public"."user_bookmarks" add constraint "unique_user_collaboration_bookmark" UNIQUE using index "unique_user_collaboration_bookmark";

alter table "public"."user_bookmarks" add constraint "unique_user_project_bookmark" UNIQUE using index "unique_user_project_bookmark";

alter table "public"."user_bookmarks" add constraint "user_bookmarks_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."user_bookmarks" validate constraint "user_bookmarks_collaboration_id_fkey";

alter table "public"."user_bookmarks" add constraint "user_bookmarks_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."user_bookmarks" validate constraint "user_bookmarks_project_id_fkey";

alter table "public"."user_bookmarks" add constraint "user_bookmarks_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_bookmarks" validate constraint "user_bookmarks_user_id_fkey";

alter table "public"."user_collaboration_preferences" add constraint "user_collaboration_preferences_collaboration_id_fkey" FOREIGN KEY (collaboration_id) REFERENCES public.collaborations(id) ON DELETE CASCADE not valid;

alter table "public"."user_collaboration_preferences" validate constraint "user_collaboration_preferences_collaboration_id_fkey";

alter table "public"."user_collaboration_preferences" add constraint "user_collaboration_preferences_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_collaboration_preferences" validate constraint "user_collaboration_preferences_profile_id_fkey";

alter table "public"."user_notification_settings" add constraint "user_notification_settings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_notification_settings" validate constraint "user_notification_settings_user_id_fkey";

alter table "public"."user_notifications" add constraint "user_notifications_receiver_id_fkey" FOREIGN KEY (receiver_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_notifications" validate constraint "user_notifications_receiver_id_fkey";

alter table "public"."user_notifications" add constraint "user_notifications_type_check" CHECK ((type = ANY (ARRAY['proposal'::text, 'invitation'::text, 'message'::text, 'deadline'::text, 'application'::text, 'status_change'::text, 'withdrawal'::text, 'follow'::text, 'like'::text, 'partnership_inquiry'::text, 'proposal_accepted'::text, 'proposal_rejected'::text, 'application_accepted'::text, 'application_rejected'::text]))) not valid;

alter table "public"."user_notifications" validate constraint "user_notifications_type_check";

alter table "public"."user_partner_preferences" add constraint "check_not_self" CHECK ((profile_id <> partner_id)) not valid;

alter table "public"."user_partner_preferences" validate constraint "check_not_self";

alter table "public"."user_partner_preferences" add constraint "user_partner_preferences_partner_id_fkey" FOREIGN KEY (partner_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_partner_preferences" validate constraint "user_partner_preferences_partner_id_fkey";

alter table "public"."user_partner_preferences" add constraint "user_partner_preferences_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_partner_preferences" validate constraint "user_partner_preferences_profile_id_fkey";

alter table "public"."user_project_preferences" add constraint "user_project_preferences_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_project_preferences" validate constraint "user_project_preferences_profile_id_fkey";

alter table "public"."user_project_preferences" add constraint "user_project_preferences_project_id_fkey" FOREIGN KEY (project_id) REFERENCES public.projects(id) ON DELETE CASCADE not valid;

alter table "public"."user_project_preferences" validate constraint "user_project_preferences_project_id_fkey";

alter table "public"."user_push_tokens" add constraint "user_push_tokens_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."user_push_tokens" validate constraint "user_push_tokens_user_id_fkey";

alter table "public"."user_push_tokens" add constraint "user_push_tokens_user_id_token_key" UNIQUE using index "user_push_tokens_user_id_token_key";

alter table "public"."user_user_preferences" add constraint "chk_uup_actor_role" CHECK (((actor_role IS NULL) OR (actor_role = ANY (ARRAY['fan'::text, 'brand'::text, 'artist'::text, 'creative'::text])))) not valid;

alter table "public"."user_user_preferences" validate constraint "chk_uup_actor_role";

alter table "public"."user_user_preferences" add constraint "user_user_preferences_preference_type_check" CHECK ((preference_type = ANY (ARRAY['follow'::text, 'like'::text]))) not valid;

alter table "public"."user_user_preferences" validate constraint "user_user_preferences_preference_type_check";

alter table "public"."user_user_preferences" add constraint "user_user_preferences_target_type_check" CHECK ((target_type = ANY (ARRAY['user'::text, 'project'::text, 'collaboration'::text, 'brand'::text, 'partner'::text]))) not valid;

alter table "public"."user_user_preferences" validate constraint "user_user_preferences_target_type_check";

alter table "public"."user_user_preferences" add constraint "user_user_preferences_user_id_fkey" FOREIGN KEY (user_id) REFERENCES public.profiles(id) ON DELETE CASCADE not valid;

alter table "public"."user_user_preferences" validate constraint "user_user_preferences_user_id_fkey";

set check_function_bodies = off;

create or replace view "public"."active_notifications" as  SELECT id,
    title,
    body,
    type,
    audiences,
    locale,
    app_min_version,
    app_max_version,
    starts_at,
    ends_at,
    is_active,
    priority,
    require_ack,
    link_url,
    created_by,
    created_at,
    updated_at,
    image_urls
   FROM public.server_notifications
  WHERE ((is_active = true) AND ((starts_at IS NULL) OR (starts_at <= now())) AND ((ends_at IS NULL) OR (ends_at >= now())));


create or replace view "public"."artists_with_stats" as  SELECT p.id,
    p.nickname,
    p.email,
    p.avatar_url,
    p.is_online,
    p.created_at AS profile_created_at,
    pa.artist_name AS name,
    pa.activity_field,
    pa.specialized_roles,
    pa.cover_image_url,
    pa.logo_image_url,
    pa.highlight_keywords,
    pa.bio,
    pa.portfolio_url,
    pa.tags,
    pa.region,
    pa.career,
    pa.career_history,
    pa.is_verified,
    pa.is_active,
    ( SELECT count(DISTINCT pm.project_id) AS count
           FROM (public.project_members pm
             JOIN public.projects proj ON ((pm.project_id = proj.id)))
          WHERE ((pm.user_id = p.id) AND (proj.status = 'completed'::text))) AS completed_projects,
    ( SELECT count(DISTINCT cm.collaboration_id) AS count
           FROM (public.collaboration_members cm
             JOIN public.collaborations c ON ((cm.collaboration_id = c.id)))
          WHERE ((cm.user_id = p.id) AND (c.status = 'completed'::text))) AS completed_collaborations,
    ( SELECT count(*) AS count
           FROM (public.project_members pm
             JOIN public.projects proj ON ((pm.project_id = proj.id)))
          WHERE ((pm.user_id = p.id) AND (pm.status = 'active'::text) AND (proj.status = 'in_progress'::text))) AS active_projects,
    ( SELECT count(*) AS count
           FROM (public.collaboration_members cm
             JOIN public.collaborations c ON ((cm.collaboration_id = c.id)))
          WHERE ((cm.user_id = p.id) AND (cm.status = 'active'::text) AND (c.status = 'in_progress'::text))) AS active_collaborations,
        CASE
            WHEN (( SELECT count(*) AS count
               FROM public.project_proposals
              WHERE (project_proposals.receiver_id = p.id)) > 0) THEN (round((((( SELECT count(*) AS count
               FROM public.project_proposals
              WHERE ((project_proposals.receiver_id = p.id) AND (project_proposals.status = 'accepted'::text))))::numeric * (100)::numeric) / (( SELECT count(*) AS count
               FROM public.project_proposals
              WHERE (project_proposals.receiver_id = p.id)))::numeric)))::integer
            ELSE 0
        END AS matching_rate,
        CASE
            WHEN (( SELECT count(*) AS count
               FROM public.project_proposals
              WHERE (project_proposals.receiver_id = p.id)) > 0) THEN (round((((( SELECT count(*) AS count
               FROM public.project_proposals
              WHERE ((project_proposals.receiver_id = p.id) AND (project_proposals.status = ANY (ARRAY['accepted'::text, 'rejected'::text])))))::numeric * (100)::numeric) / (( SELECT count(*) AS count
               FROM public.project_proposals
              WHERE (project_proposals.receiver_id = p.id)))::numeric)))::integer
            ELSE 0
        END AS response_rate,
    (( SELECT avg(EXTRACT(epoch FROM (project_proposals.response_date - project_proposals.sent_date))) AS avg
           FROM public.project_proposals
          WHERE ((project_proposals.receiver_id = p.id) AND (project_proposals.response_date IS NOT NULL))))::integer AS avg_response_time_seconds,
    (0)::numeric AS rating,
    0 AS review_count
   FROM (public.profiles p
     JOIN public.profile_artists pa ON ((p.id = pa.profile_id)))
  WHERE (pa.is_active = true);


CREATE OR REPLACE FUNCTION public.can_add_self_as_member_via_proposal(target_project_id uuid, target_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM public.project_proposals
    WHERE project_id = target_project_id
      AND receiver_id = target_user_id
      AND status = 'accepted'
  );
$function$
;

CREATE OR REPLACE FUNCTION public.check_notification_enabled(user_uuid uuid, notif_type text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM user_notification_settings 
        WHERE user_id = user_uuid 
        AND notification_type = notif_type 
        AND is_enabled = true
    ) OR NOT EXISTS (
        SELECT 1 
        FROM user_notification_settings 
        WHERE user_id = user_uuid 
        AND notification_type = notif_type
    ); -- Default true if no setting exists
END;
$function$
;

create or replace view "public"."collaborations_with_stats" as  SELECT c.id,
    c.created_by,
    c.title,
    c.brief_description,
    c.description,
    c.category,
    c.collaboration_type,
    c.skills,
    c.budget_range,
    c.budget_min,
    c.budget_max,
    c.budget_currency,
    c.duration,
    c.scheduled_start_date,
    c.scheduled_end_date,
    c.status,
    c.team_size,
    c.current_team_size,
    c.min_experience_years,
    c.work_type,
    c.location,
    c.cover_image_url,
    c.images,
    c.video_url,
    c.tags,
    c.requirements,
    c.benefits,
    c.goals,
    c.expected_outcome,
    c.profit_sharing,
    c.workflow_steps,
    c.files,
    c.view_count,
    c.bookmark_count,
    c.invitation_count,
    c.application_count,
    c.is_featured,
    c.is_urgent,
    c.is_remote_friendly,
    c.visibility,
    c.created_at,
    c.updated_at,
    c.published_at,
    c.started_at,
    c.closed_at,
    COALESCE(cs.view_count, 0) AS stats_view_count,
    COALESCE(cs.bookmark_count, 0) AS stats_bookmark_count,
    cs.last_viewed_at,
    ( SELECT count(*) AS count
           FROM public.collaboration_invitations
          WHERE (collaboration_invitations.collaboration_id = c.id)) AS invitation_count_calc,
    ( SELECT count(*) AS count
           FROM public.collaboration_members
          WHERE ((collaboration_members.collaboration_id = c.id) AND (collaboration_members.status = 'active'::text))) AS member_count
   FROM (public.collaborations c
     LEFT JOIN public.collaboration_stats cs ON ((c.id = cs.collaboration_id)));


create or replace view "public"."community_activity_feed" as  SELECT 'like'::text AS activity_type,
    ll.id,
    ll.created_at,
    ll.user_id,
    COALESCE(ll.actor_name, p.nickname) AS user_name,
    COALESCE(ll.actor_avatar_url, p.avatar_url) AS user_avatar,
    ll.actor_role AS user_role,
    COALESCE(ll.project_id, ll.collaboration_id) AS entity_id,
        CASE
            WHEN (ll.project_id IS NOT NULL) THEN 'project'::text
            ELSE 'collaboration'::text
        END AS entity_type,
    COALESCE(proj.title, collab.title) AS entity_title,
    COALESCE(proj.cover_image_url, collab.cover_image_url) AS entity_image
   FROM (((public.lounge_likes ll
     LEFT JOIN public.profiles p ON ((ll.user_id = p.id)))
     LEFT JOIN public.projects proj ON ((ll.project_id = proj.id)))
     LEFT JOIN public.collaborations collab ON ((ll.collaboration_id = collab.id)))
  WHERE (ll.is_canceled = false)
UNION ALL
 SELECT 'comment'::text AS activity_type,
    lc.id,
    lc.created_at,
    lc.author_id AS user_id,
    p.nickname AS user_name,
    p.avatar_url AS user_avatar,
    lc.author_role AS user_role,
    COALESCE(lc.project_id, lc.collaboration_id) AS entity_id,
        CASE
            WHEN (lc.project_id IS NOT NULL) THEN 'project'::text
            ELSE 'collaboration'::text
        END AS entity_type,
    COALESCE(proj.title, collab.title) AS entity_title,
    COALESCE(proj.cover_image_url, collab.cover_image_url) AS entity_image
   FROM (((public.lounge_comments lc
     LEFT JOIN public.profiles p ON ((lc.author_id = p.id)))
     LEFT JOIN public.projects proj ON ((lc.project_id = proj.id)))
     LEFT JOIN public.collaborations collab ON ((lc.collaboration_id = collab.id)))
  ORDER BY 3 DESC;


create or replace view "public"."creatives_with_stats" as  SELECT p.id,
    p.nickname,
    p.email,
    p.avatar_url,
    p.is_online,
    p.created_at AS profile_created_at,
    pc.nickname AS name,
    pc.activity_field,
    pc.profile_image_url,
    pc.sns_channels,
    pc.main_sns_channel,
    pc.acquisition_source,
    pc.bio,
    pc.tags,
    pc.region,
    pc.career,
    pc.career_history,
    pc.is_verified,
    pc.is_active,
    ( SELECT count(DISTINCT pm.project_id) AS count
           FROM (public.project_members pm
             JOIN public.projects proj ON ((pm.project_id = proj.id)))
          WHERE ((pm.user_id = p.id) AND (proj.status = 'completed'::text))) AS completed_projects,
    ( SELECT count(DISTINCT cm.collaboration_id) AS count
           FROM (public.collaboration_members cm
             JOIN public.collaborations c ON ((cm.collaboration_id = c.id)))
          WHERE ((cm.user_id = p.id) AND (c.status = 'completed'::text))) AS completed_collaborations,
    ( SELECT count(*) AS count
           FROM (public.project_members pm
             JOIN public.projects proj ON ((pm.project_id = proj.id)))
          WHERE ((pm.user_id = p.id) AND (pm.status = 'active'::text) AND (proj.status = 'in_progress'::text))) AS active_projects,
    ( SELECT count(*) AS count
           FROM (public.collaboration_members cm
             JOIN public.collaborations c ON ((cm.collaboration_id = c.id)))
          WHERE ((cm.user_id = p.id) AND (cm.status = 'active'::text) AND (c.status = 'in_progress'::text))) AS active_collaborations,
        CASE
            WHEN (( SELECT count(*) AS count
               FROM public.collaboration_invitations
              WHERE (collaboration_invitations.invitee_id = p.id)) > 0) THEN (round((((( SELECT count(*) AS count
               FROM public.collaboration_invitations
              WHERE ((collaboration_invitations.invitee_id = p.id) AND (collaboration_invitations.status = 'accepted'::text))))::numeric * (100)::numeric) / (( SELECT count(*) AS count
               FROM public.collaboration_invitations
              WHERE (collaboration_invitations.invitee_id = p.id)))::numeric)))::integer
            ELSE 0
        END AS matching_rate,
        CASE
            WHEN (( SELECT count(*) AS count
               FROM public.collaboration_invitations
              WHERE (collaboration_invitations.invitee_id = p.id)) > 0) THEN (round((((( SELECT count(*) AS count
               FROM public.collaboration_invitations
              WHERE ((collaboration_invitations.invitee_id = p.id) AND (collaboration_invitations.status = ANY (ARRAY['accepted'::text, 'rejected'::text])))))::numeric * (100)::numeric) / (( SELECT count(*) AS count
               FROM public.collaboration_invitations
              WHERE (collaboration_invitations.invitee_id = p.id)))::numeric)))::integer
            ELSE 0
        END AS response_rate,
    (( SELECT avg(EXTRACT(epoch FROM (collaboration_invitations.response_date - collaboration_invitations.sent_date))) AS avg
           FROM public.collaboration_invitations
          WHERE ((collaboration_invitations.invitee_id = p.id) AND (collaboration_invitations.response_date IS NOT NULL))))::integer AS avg_response_time_seconds,
    (0)::numeric AS rating,
    0 AS review_count
   FROM (public.profiles p
     JOIN public.profile_creatives pc ON ((p.id = pc.profile_id)))
  WHERE (pc.is_active = true);


CREATE OR REPLACE FUNCTION public.fn_assert_single_active_nonfan(p_user uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_cnt int;
begin
  select
    coalesce((select count(1) from public.profile_brands where profile_id = p_user and is_active = true), 0)
  + coalesce((select count(1) from public.profile_artists where profile_id = p_user and is_active = true), 0)
  + coalesce((select count(1) from public.profile_creatives where profile_id = p_user and is_active = true), 0)
  into v_cnt;

  if v_cnt > 1 then
    raise exception 'Only one active non-fan profile is allowed per user' using errcode = '23514';
  end if;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.get_admin_all_users()
 RETURNS TABLE(user_type text, profile_id uuid, display_name text, category text, created_at timestamp with time zone, approval_status text, email text)
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  SELECT 
    'artist' as user_type,
    pa.profile_id,
    pa.artist_name as display_name,
    pa.activity_field as category,
    pa.created_at,
    'approved' as approval_status,
    get_auth_email(pa.profile_id) as email
  FROM public.profile_artists pa

  UNION ALL

  SELECT 
    'brand' as user_type,
    pb.profile_id,
    pb.brand_name as display_name,
    pb.category,
    pb.created_at,
    'approved' as approval_status,
    get_auth_email(pb.profile_id) as email
  FROM public.profile_brands pb

  UNION ALL

  SELECT 
    'creative' as user_type,
    pc.profile_id,
    pc.nickname as display_name,
    NULL as category,
    pc.created_at,
    pc.approval_status,
    get_auth_email(pc.profile_id) as email
  FROM public.profile_creatives pc

  UNION ALL

  SELECT 
    'fan' as user_type,
    pf.profile_id,
    pp.nickname as display_name,
    NULL as category,
    pf.created_at,
    COALESCE(pf.approval_status, 'approved') as approval_status,
    get_auth_email(pf.profile_id) as email
  FROM public.profile_fans pf
  JOIN public.profiles pp ON pf.profile_id = pp.id;
$function$
;

CREATE OR REPLACE FUNCTION public.get_admin_all_users_cautious(caller uuid)
 RETURNS TABLE(user_type text, profile_id uuid, display_name text, category text, created_at timestamp with time zone, approval_status text, email text)
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
  --    :    
  WITH is_admin AS (
    SELECT 1
    FROM public.admins a
    WHERE a.user_id = caller
      AND a.role IN ('admin', 'super_admin')
    LIMIT 1
  )
  SELECT *
  FROM (
    --  : is_admin     SELECT is_admin  
    SELECT 
      'artist' as user_type,
      pa.profile_id,
      pa.artist_name as display_name,
      pa.activity_field as category,
      pa.created_at,
      'approved' as approval_status,
      get_auth_email(pa.profile_id) as email
    FROM public.profile_artists pa
    WHERE EXISTS (SELECT 1 FROM is_admin)

    UNION ALL

    SELECT 
      'brand' as user_type,
      pb.profile_id,
      pb.brand_name as display_name,
      pb.category,
      pb.created_at,
      'approved' as approval_status,
      get_auth_email(pb.profile_id) as email
    FROM public.profile_brands pb
    WHERE EXISTS (SELECT 1 FROM is_admin)

    UNION ALL

    SELECT 
      'creative' as user_type,
      pc.profile_id,
      pc.nickname as display_name,
      NULL as category,
      pc.created_at,
      pc.approval_status,
      get_auth_email(pc.profile_id) as email
    FROM public.profile_creatives pc
    WHERE EXISTS (SELECT 1 FROM is_admin)

    UNION ALL

    SELECT 
      'fan' as user_type,
      pf.profile_id,
      pp.nickname as display_name,
      NULL as category,
      pf.created_at,
      COALESCE(pf.approval_status, 'approved') as approval_status,
      get_auth_email(pf.profile_id) as email
    FROM public.profile_fans pf
    JOIN public.profiles pp ON pf.profile_id = pp.id
    WHERE EXISTS (SELECT 1 FROM is_admin)
  ) t;
$function$
;

CREATE OR REPLACE FUNCTION public.get_auth_email(user_id uuid)
 RETURNS text
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
  SELECT email FROM auth.users WHERE id = user_id;
$function$
;

--       
CREATE OR REPLACE FUNCTION public.get_vfan_display_name(user_id uuid)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    display_name text;
    user_roles text[];
BEGIN
    -- Get user roles
    SELECT roles INTO user_roles FROM profiles WHERE id = user_id;
    
    -- Get display name based on roles priority: brand > artist > creative > nickname
    IF user_roles IS NOT NULL THEN
        IF 'brand' = ANY(user_roles) THEN
            SELECT brand_name INTO display_name
            FROM profile_brands 
            WHERE profile_id = user_id AND is_active = true;
        END IF;
        
        IF display_name IS NULL AND 'artist' = ANY(user_roles) THEN
            SELECT artist_name INTO display_name
            FROM profile_artists 
            WHERE profile_id = user_id AND is_active = true;
        END IF;
        
        IF display_name IS NULL AND 'creative' = ANY(user_roles) THEN
            SELECT nickname INTO display_name
            FROM profile_creatives 
            WHERE profile_id = user_id AND is_active = true;
        END IF;
    END IF;
    
    -- Fallback to profiles.nickname if no role-specific name found
    IF display_name IS NULL THEN
        SELECT nickname INTO display_name FROM profiles WHERE id = user_id;
    END IF;
    
    -- Final fallback
    IF display_name IS NULL THEN
        display_name := '';
    END IF;
    
    RETURN display_name;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_collaboration_application_withdrawal()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    collab_title text;
    applicant_name text;
    owner_id uuid;
BEGIN
    -- status 'withdrawn' ,   'pending', 'reviewed', 'shortlisted'     
    IF NEW.status = 'withdrawn' AND OLD.status IN ('pending', 'reviewed', 'shortlisted') THEN
        SELECT title, created_by INTO collab_title, owner_id FROM collaborations WHERE id = NEW.collaboration_id;
        SELECT get_vfan_display_name(NEW.applicant_id) INTO applicant_name;

        -- Check setting (  )
        IF check_notification_enabled(owner_id, 'application') THEN
            INSERT INTO user_notifications (
                receiver_id, type, title, content, related_id, related_type, metadata
            ) VALUES (
                owner_id,
                'withdrawal',
                ' ',
                applicant_name || ' "' || collab_title || '"   .',
                NEW.collaboration_id,
                'collaboration',
                jsonb_build_object(
                    'application_id', NEW.id,
                    'sender_id', NEW.applicant_id,
                    'sender_name', applicant_name,
                    'previous_status', OLD.status
                )
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_chat_message()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    room_title text;
    sender_name text;
    participant RECORD;
    message_content text;
    has_content boolean;
    has_attachments boolean;
    image_count integer;
    file_count integer;
BEGIN
    -- Get room title (fallback to '')
    SELECT COALESCE(title, '') INTO room_title FROM chat_rooms WHERE id = NEW.room_id;
    -- Get sender name (   )
    SELECT get_vfan_display_name(NEW.sender_id) INTO sender_name;

    -- Check if message has content
    has_content := (NEW.content IS NOT NULL AND trim(NEW.content) != '');
    
    -- Check attachments
    has_attachments := (NEW.attachments IS NOT NULL AND jsonb_array_length(NEW.attachments) > 0);
    
    -- Determine message content based on attachments and text
    IF has_attachments THEN
        -- Count image and file attachments
        SELECT 
            COUNT(*) FILTER (WHERE (elem->>'type') = 'image'),
            COUNT(*) FILTER (WHERE (elem->>'type') = 'file')
        INTO image_count, file_count
        FROM jsonb_array_elements(NEW.attachments) AS elem;
        
        IF has_content THEN
            -- Has both attachments and content
            IF image_count > 0 AND file_count > 0 THEN
                message_content := sender_name || ': (/)  ';
            ELSIF image_count > 0 THEN
                message_content := sender_name || ': ()  ';
            ELSE
                message_content := sender_name || ': ()  ';
            END IF;
        ELSE
            -- Only attachments, no content
            IF image_count > 0 AND file_count > 0 THEN
                message_content := sender_name || ': / ';
            ELSIF image_count > 0 THEN
                message_content := sender_name || ':  ';
            ELSE
                message_content := sender_name || ':  ';
            END IF;
        END IF;
    ELSIF has_content THEN
        -- Only content, no attachments
        message_content := sender_name || ': ' || substring(NEW.content from 1 for 50);
    ELSE
        -- Fallback (shouldn't happen, but just in case)
        message_content := sender_name || ':  ';
    END IF;

    -- Loop through all participants except sender
    FOR participant IN 
        SELECT user_id 
        FROM chat_participants 
        WHERE room_id = NEW.room_id 
        AND user_id != NEW.sender_id
    LOOP
        IF check_notification_enabled(participant.user_id, 'message') THEN
            INSERT INTO user_notifications (
                receiver_id, type, title, content, related_id, related_type, metadata
            ) VALUES (
                participant.user_id,
                'message',
                room_title,
                message_content,
                NEW.room_id,
                'chat',
                jsonb_build_object(
                    'message_id', NEW.id,
                    'sender_id', NEW.sender_id,
                    'sender_name', sender_name
                )
            );
        END IF;
    END LOOP;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_collaboration_application()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    collab_title text;
    applicant_name text;
    owner_id uuid;
BEGIN
    SELECT title, created_by INTO collab_title, owner_id FROM collaborations WHERE id = NEW.collaboration_id;
    SELECT get_vfan_display_name(NEW.applicant_id) INTO applicant_name;

    IF check_notification_enabled(owner_id, 'application') THEN
        INSERT INTO user_notifications (
            receiver_id, type, title, content, related_id, related_type, metadata
        ) VALUES (
            owner_id,
            'application',
            '  ',
            applicant_name || ' "' || collab_title || '"  .',
            NEW.collaboration_id,
            'collaboration',
            jsonb_build_object(
                'application_id', NEW.id,
                'sender_id', NEW.applicant_id,
                'sender_name', applicant_name
            )
        );
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_invitation()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    collab_title text;
    inviter_name text;
BEGIN
    SELECT title INTO collab_title FROM collaborations WHERE id = NEW.collaboration_id;
    SELECT get_vfan_display_name(NEW.inviter_id) INTO inviter_name;

    IF check_notification_enabled(NEW.invitee_id, 'invitation') THEN
        INSERT INTO user_notifications (
            receiver_id, type, title, content, related_id, related_type, metadata
        ) VALUES (
            NEW.invitee_id,
            'invitation',
            '  ',
            inviter_name || ' "' || collab_title || '"  .',
            NEW.collaboration_id,
            'collaboration',
            jsonb_build_object(
                'invitation_id', NEW.id,
                'sender_id', NEW.inviter_id,
                'sender_name', inviter_name
            )
        );
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_partnership_inquiry()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    sender_name text;
    sender_avatar text;
    company_name text;
    sender_roles text[];
BEGIN
    -- Get sender name (   )
    SELECT get_vfan_display_name(NEW.sender_id) INTO sender_name;
    
    -- Get sender roles for avatar
    SELECT roles INTO sender_roles FROM profiles WHERE id = NEW.sender_id;
    
    -- Get sender avatar based on roles priority: brand > artist > creative
    IF sender_roles IS NOT NULL THEN
        IF 'brand' = ANY(sender_roles) THEN
            SELECT logo_image_url INTO sender_avatar
            FROM profile_brands 
            WHERE profile_id = NEW.sender_id AND is_active = true;
        END IF;
        
        IF sender_avatar IS NULL AND 'artist' = ANY(sender_roles) THEN
            SELECT logo_image_url INTO sender_avatar
            FROM profile_artists 
            WHERE profile_id = NEW.sender_id AND is_active = true;
        END IF;
        
        IF sender_avatar IS NULL AND 'creative' = ANY(sender_roles) THEN
            SELECT profile_image_url INTO sender_avatar
            FROM profile_creatives 
            WHERE profile_id = NEW.sender_id AND is_active = true;
        END IF;
    END IF;
    
    -- Fallback to profiles.avatar_url if no role-specific avatar found
    IF sender_avatar IS NULL THEN
        SELECT avatar_url INTO sender_avatar FROM profiles WHERE id = NEW.sender_id;
    END IF;

    -- Use provided company name or fall back to sender name
    company_name := COALESCE(NEW.company_name, sender_name);

    -- Create notification
    INSERT INTO public.user_notifications (
        receiver_id,
        type,
        title,
        content,
        related_id,
        related_type,
        metadata,
        is_read,
        created_at
    ) VALUES (
        NEW.receiver_id,
        'partnership_inquiry', -- New type
        '  ',
        company_name || '    .',
        NEW.id,
        'partnership_inquiry',
        jsonb_build_object(
            'sender_id', NEW.sender_id,
            'sender_name', sender_name,
            'sender_avatar', sender_avatar,
            'project_type', NEW.project_type
        ),
        false,
        now()
    );

    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_project_application()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    project_title text;
    applicant_name text;
    owner_id uuid;
BEGIN
    SELECT title, created_by INTO project_title, owner_id FROM projects WHERE id = NEW.project_id;
    SELECT get_vfan_display_name(NEW.applicant_id) INTO applicant_name;

    IF check_notification_enabled(owner_id, 'application') THEN
        INSERT INTO user_notifications (
            receiver_id, type, title, content, related_id, related_type, metadata
        ) VALUES (
            owner_id,
            'application',
            '  ',
            applicant_name || ' "' || project_title || '"  .',
            NEW.project_id,
            'project',
            jsonb_build_object(
                'application_id', NEW.id,
                'sender_id', NEW.applicant_id,
                'sender_name', applicant_name
            )
        );
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_proposal()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    project_title text;
    sender_name text;
    sender_avatar text;
    sender_roles text[];
BEGIN
    -- Get project title
    SELECT title INTO project_title FROM projects WHERE id = NEW.project_id;
    
    -- Get sender name (   )
    SELECT get_vfan_display_name(NEW.sender_id) INTO sender_name;
    
    -- Get sender roles for avatar
    SELECT roles INTO sender_roles FROM profiles WHERE id = NEW.sender_id;
    
    -- Get sender avatar based on roles priority: brand > artist > creative
    IF sender_roles IS NOT NULL THEN
        IF 'brand' = ANY(sender_roles) THEN
            SELECT logo_image_url INTO sender_avatar
            FROM profile_brands 
            WHERE profile_id = NEW.sender_id AND is_active = true;
        END IF;
        
        IF sender_avatar IS NULL AND 'artist' = ANY(sender_roles) THEN
            SELECT logo_image_url INTO sender_avatar
            FROM profile_artists 
            WHERE profile_id = NEW.sender_id AND is_active = true;
        END IF;
        
        IF sender_avatar IS NULL AND 'creative' = ANY(sender_roles) THEN
            SELECT profile_image_url INTO sender_avatar
            FROM profile_creatives 
            WHERE profile_id = NEW.sender_id AND is_active = true;
        END IF;
    END IF;

    -- Check setting and insert notification
    IF check_notification_enabled(NEW.receiver_id, 'proposal') THEN
        INSERT INTO user_notifications (
            receiver_id, type, title, content, related_id, related_type, metadata
        ) VALUES (
            NEW.receiver_id,
            'proposal',
            '  ',
            sender_name || ' "' || COALESCE(project_title, '') || '"   .',
            NEW.project_id,
            'project',
            jsonb_build_object(
                'proposal_id', NEW.id,
                'sender_id', NEW.sender_id,
                'sender_name', sender_name,
                'sender_avatar', sender_avatar
            )
        );
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  INSERT INTO public.profiles (
    id, 
    username, 
    nickname, 
    roles, 
    avatar_url, 
    terms_agreed_at, 
    marketing_agreed_at, 
    banned_until, 
    last_access, 
    email
  )
  VALUES (
    NEW.id,
    NEW.raw_user_meta_data->>'full_name', -- Google/Apple  
    NULL,
    ARRAY['customer']::text[], --   !
    NEW.raw_user_meta_data->>'avatar_url', -- Google/Apple  
    NULL,
    NULL,
    NULL,
    NOW(),
    NEW.email --  raw_app_meta_data  NEW.email  ( )
  );
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_project_application_withdrawal()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    project_title text;
    applicant_name text;
    owner_id uuid;
BEGIN
    -- status 'withdrawn' ,   'pending', 'reviewed', 'shortlisted'     
    IF NEW.status = 'withdrawn' AND OLD.status IN ('pending', 'reviewed', 'shortlisted') THEN
        SELECT title, created_by INTO project_title, owner_id FROM projects WHERE id = NEW.project_id;
        SELECT get_vfan_display_name(NEW.applicant_id) INTO applicant_name;

        -- Check setting (  )
        IF check_notification_enabled(owner_id, 'application') THEN
            INSERT INTO user_notifications (
                receiver_id, type, title, content, related_id, related_type, metadata
            ) VALUES (
                owner_id,
                'withdrawal',
                ' ',
                applicant_name || ' "' || project_title || '"   .',
                NEW.project_id,
                'project',
                jsonb_build_object(
                    'application_id', NEW.id,
                    'sender_id', NEW.applicant_id,
                    'sender_name', applicant_name,
                    'previous_status', OLD.status
                )
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_proposal_withdrawal()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    project_title text;
    sender_name text;
BEGIN
    -- status 'withdrawn' ,   'pending'   
    IF NEW.status = 'withdrawn' AND OLD.status = 'pending' THEN
        -- Get project title
        SELECT title INTO project_title FROM projects WHERE id = NEW.project_id;
        -- Get sender name (   )
        SELECT get_vfan_display_name(NEW.sender_id) INTO sender_name;

        -- Check setting (receiver )
        IF check_notification_enabled(NEW.receiver_id, 'proposal') THEN
            INSERT INTO user_notifications (
                receiver_id, type, title, content, related_id, related_type, metadata
            ) VALUES (
                NEW.receiver_id,
                'withdrawal',
                ' ',
                sender_name || ' "' || project_title || '"   .',
                NEW.project_id,
                'project',
                jsonb_build_object(
                    'proposal_id', NEW.id,
                    'sender_id', NEW.sender_id,
                    'sender_name', sender_name,
                    'previous_status', OLD.status
                )
            );
        END IF;
    END IF;
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.has_admin_management_permission(uid uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
  SELECT EXISTS (
    SELECT 1 FROM public.admins a
    WHERE a.profile_id = uid
    AND (
      a.role = 'super_admin' 
      OR 'admin_management' = ANY(a.permissions)
    )
  );
$function$
;

create or replace view "public"."homepage_new_brands_artists" as  SELECT pb.profile_id AS id,
    pb.brand_name AS name,
    'brand'::text AS role,
    pb.logo_image_url,
    pb.activity_field AS category_field,
    pb.created_at
   FROM public.profile_brands pb
  WHERE ((pb.is_active = true) AND (pb.approval_status = 'approved'::text))
UNION ALL
 SELECT pa.profile_id AS id,
    pa.artist_name AS name,
    'artist'::text AS role,
    pa.logo_image_url,
    pa.activity_field AS category_field,
    pa.created_at
   FROM public.profile_artists pa
  WHERE (pa.is_active = true);


CREATE OR REPLACE FUNCTION public.increment_magazine_view_count(magazine_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
BEGIN
  UPDATE magazines SET view_count = view_count + 1 WHERE id = magazine_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_admin(uid uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
  select exists (
    select 1 from public.admins a
    where a.profile_id = uid
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_collaboration_leader(collab_id uuid, user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM collaboration_members
    WHERE collaboration_id = collab_id
      AND user_id = user_id
      AND is_leader = true
      AND can_invite = true
      AND status = 'active'
  );
$function$
;

CREATE OR REPLACE FUNCTION public.is_project_creator(target_project_id uuid, target_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    select exists (
        select 1
        from public.projects
        where id = target_project_id
          and created_by = target_user_id
    );
$function$
;

CREATE OR REPLACE FUNCTION public.is_project_leader_with_invite(target_project_id uuid, target_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    select exists (
        select 1
        from public.project_members
        where project_id = target_project_id
          and user_id = target_user_id
          and is_leader = true
          and can_invite = true
    );
$function$
;

CREATE OR REPLACE FUNCTION public.is_project_member(target_project_id uuid, target_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    select exists (
        select 1
        from public.project_members
        where project_id = target_project_id
          and user_id = target_user_id
    );
$function$
;

CREATE OR REPLACE FUNCTION public.is_super_admin(uid uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public', 'auth'
AS $function$
  select exists (
    select 1 from public.admins a
    where a.profile_id = uid
      and a.role = 'super_admin'
  );
$function$
;

CREATE OR REPLACE FUNCTION public.kick_chat_participant(p_room_id uuid, p_target_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
declare
  actor_role chat_participant_role;
begin
  select role into actor_role
  from chat_participants
  where room_id = p_room_id and user_id = auth.uid();

  if actor_role is null or actor_role not in ('owner','admin') then
    raise exception ' ';
  end if;

  if exists(select 1 from chat_participants where room_id = p_room_id and user_id = p_target_user_id and role = 'owner') then
    raise exception '   ';
  end if;

  delete from chat_participants
  where room_id = p_room_id and user_id = p_target_user_id;
end;
$function$
;

create or replace view "public"."live_brand_metrics" as  WITH base_apps AS (
         SELECT p.created_by AS brand_id,
            pa.applied_date AS sent_at,
            COALESCE(pa.response_date, pa.updated_at) AS responded_at,
            pa.status
           FROM (public.project_applications pa
             JOIN public.projects p ON ((p.id = pa.project_id)))
          WHERE (pa.applied_date IS NOT NULL)
        UNION ALL
         SELECT c.created_by AS brand_id,
            ca.applied_date AS sent_at,
            COALESCE(ca.response_date, ca.updated_at) AS responded_at,
            ca.status
           FROM (public.collaboration_applications ca
             JOIN public.collaborations c ON ((c.id = ca.collaboration_id)))
          WHERE (ca.applied_date IS NOT NULL)
        ), normalized AS (
         SELECT base_apps.brand_id,
            base_apps.sent_at,
            base_apps.responded_at,
            base_apps.status,
                CASE
                    WHEN ((base_apps.responded_at IS NOT NULL) OR (base_apps.status = ANY (ARRAY['accepted'::text, 'rejected'::text, 'declined'::text, 'expired'::text, 'withdrawn'::text, 'cancelled'::text, 'canceled'::text, 'reviewed'::text, 'shortlisted'::text]))) THEN 1
                    ELSE 0
                END AS responded_flag,
                CASE
                    WHEN (base_apps.status = 'accepted'::text) THEN 1
                    ELSE 0
                END AS accepted_flag,
                CASE
                    WHEN (base_apps.status = ANY (ARRAY['accepted'::text, 'rejected'::text, 'declined'::text, 'expired'::text, 'withdrawn'::text, 'cancelled'::text, 'canceled'::text, 'reviewed'::text, 'shortlisted'::text])) THEN 1
                    ELSE 0
                END AS resolved_flag,
            GREATEST(EXTRACT(epoch FROM (base_apps.responded_at - base_apps.sent_at)), (0)::numeric) AS response_seconds
           FROM base_apps
          WHERE (base_apps.sent_at IS NOT NULL)
        )
 SELECT brand_id,
    round(COALESCE((((sum(responded_flag))::numeric * 100.0) / (NULLIF(count(*), 0))::numeric), (0)::numeric), 1) AS response_rate,
        CASE
            WHEN (sum(responded_flag) > 0) THEN round(((percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((response_seconds)::double precision)) / (3600.0)::double precision))::numeric, 2)
            ELSE NULL::numeric
        END AS response_time_hours,
    round(COALESCE((((sum(accepted_flag))::numeric * 100.0) / (NULLIF(sum(resolved_flag), 0))::numeric), (0)::numeric), 1) AS matching_rate,
    count(*) AS total_received,
    sum(responded_flag) AS total_responded,
    sum(resolved_flag) AS total_resolved,
    sum(accepted_flag) AS total_accepted
   FROM normalized
  GROUP BY brand_id;


create or replace view "public"."live_partner_metrics" as  WITH interactions AS (
         SELECT pp.receiver_id AS user_id,
            pp.sent_date AS sent_at,
            COALESCE(pp.response_date, pp.updated_at) AS responded_at,
            pp.status
           FROM public.project_proposals pp
          WHERE (pp.sent_date IS NOT NULL)
        UNION ALL
         SELECT ci.invitee_id AS user_id,
            ci.sent_date AS sent_at,
            COALESCE(ci.response_date, ci.updated_at) AS responded_at,
            ci.status
           FROM public.collaboration_invitations ci
          WHERE (ci.sent_date IS NOT NULL)
        ), normalized AS (
         SELECT interactions.user_id,
            interactions.sent_at,
            interactions.responded_at,
            interactions.status,
                CASE
                    WHEN ((interactions.responded_at IS NOT NULL) OR (interactions.status = ANY (ARRAY['accepted'::text, 'rejected'::text, 'declined'::text, 'expired'::text, 'withdrawn'::text, 'cancelled'::text, 'canceled'::text]))) THEN 1
                    ELSE 0
                END AS responded_flag,
                CASE
                    WHEN (interactions.status = 'accepted'::text) THEN 1
                    ELSE 0
                END AS accepted_flag,
                CASE
                    WHEN (interactions.status = ANY (ARRAY['accepted'::text, 'rejected'::text, 'declined'::text, 'expired'::text, 'withdrawn'::text, 'cancelled'::text, 'canceled'::text])) THEN 1
                    ELSE 0
                END AS resolved_flag,
            GREATEST(EXTRACT(epoch FROM (interactions.responded_at - interactions.sent_at)), (0)::numeric) AS response_seconds
           FROM interactions
          WHERE (interactions.sent_at IS NOT NULL)
        )
 SELECT user_id,
    round(COALESCE((((sum(responded_flag))::numeric * 100.0) / (NULLIF(count(*), 0))::numeric), (0)::numeric), 1) AS response_rate,
        CASE
            WHEN (sum(responded_flag) > 0) THEN round(((percentile_cont((0.5)::double precision) WITHIN GROUP (ORDER BY ((response_seconds)::double precision)) / (3600.0)::double precision))::numeric, 2)
            ELSE NULL::numeric
        END AS response_time_hours,
    round(COALESCE((((sum(accepted_flag))::numeric * 100.0) / (NULLIF(sum(resolved_flag), 0))::numeric), (0)::numeric), 1) AS matching_rate,
    count(*) AS total_received,
    sum(responded_flag) AS total_responded,
    sum(resolved_flag) AS total_resolved,
    sum(accepted_flag) AS total_accepted
   FROM normalized
  GROUP BY user_id;


CREATE OR REPLACE FUNCTION public.moddatetime()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$function$
;

create or replace view "public"."partners" as  SELECT pa.profile_id AS id,
    pa.artist_name AS name,
    pa.activity_field,
    'artist'::text AS role,
    pa.specialized_roles,
    pa.tags,
    pa.bio,
    pa.logo_image_url AS profile_image_url,
    pa.cover_image_url,
    ps.portfolio_images,
    ps.rating,
    ps.review_count,
    ps.completed_projects,
    ps.region,
    ps.matching_rate,
    ps.response_rate,
    ps.response_time,
    ps.career,
    ps.is_online,
    ps.is_verified,
    ps.career_history,
    pa.created_at
   FROM (public.profile_artists pa
     LEFT JOIN public.partner_stats ps ON ((ps.profile_id = pa.profile_id)))
  WHERE COALESCE(pa.is_active, true)
UNION ALL
 SELECT pc.profile_id AS id,
    pc.nickname AS name,
    pc.activity_field,
    'creative'::text AS role,
    ARRAY[]::text[] AS specialized_roles,
    pc.tags,
    pc.bio,
    pc.profile_image_url,
    NULL::text AS cover_image_url,
    ps.portfolio_images,
    ps.rating,
    ps.review_count,
    ps.completed_projects,
    ps.region,
    ps.matching_rate,
    ps.response_rate,
    ps.response_time,
    ps.career,
    ps.is_online,
    ps.is_verified,
    ps.career_history,
    pc.created_at
   FROM (public.profile_creatives pc
     LEFT JOIN public.partner_stats ps ON ((ps.profile_id = pc.profile_id)))
  WHERE COALESCE(pc.is_active, true);


create or replace view "public"."popular_searches" as  SELECT query,
    count(*) AS search_count,
    max(created_at) AS last_searched
   FROM public.search_history
  WHERE ((created_at > (now() - '7 days'::interval)) AND (query IS NOT NULL) AND (length(TRIM(BOTH FROM query)) >= 2))
  GROUP BY query
  ORDER BY (count(*)) DESC, (max(created_at)) DESC
 LIMIT 20;


CREATE OR REPLACE FUNCTION public.profile_create_guard(p_user uuid, p_type text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  if lower(p_type) in ('brand','artist','creative') then
    perform public.fn_assert_single_active_nonfan(p_user);
  end if;
  return true;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.profile_switch(p_user uuid, p_target_type text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  if lower(p_target_type) = 'brand' then
    update public.profile_artists set is_active = false where profile_id = p_user and is_active = true;
    update public.profile_creatives set is_active = false where profile_id = p_user and is_active = true;
  elsif lower(p_target_type) = 'artist' then
    update public.profile_brands set is_active = false where profile_id = p_user and is_active = true;
    update public.profile_creatives set is_active = false where profile_id = p_user and is_active = true;
  elsif lower(p_target_type) = 'creative' then
    update public.profile_brands set is_active = false where profile_id = p_user and is_active = true;
    update public.profile_artists set is_active = false where profile_id = p_user and is_active = true;
  elsif lower(p_target_type) = 'fan' then
    with ranked as (
      select ctid, row_number() over (order by created_at desc nulls last) as rn
      from public.profile_fans where profile_id = p_user and is_active = true
    )
    update public.profile_fans f
    set is_active = false
    from ranked r
    where f.ctid = r.ctid and r.rn > 1;
  else
    raise exception 'unknown target_type: %', p_target_type;
  end if;

  perform public.fn_assert_single_active_nonfan(p_user);
end;
$function$
;

create or replace view "public"."projects_with_stats" as  SELECT p.id,
    p.created_by,
    p.title,
    p.description,
    p.category,
    p.budget_range,
    p.budget_min,
    p.budget_max,
    p.budget_type,
    p.budget_currency,
    p.duration,
    p.deadline,
    p.scheduled_start_date,
    p.scheduled_end_date,
    p.status,
    p.skills,
    p.team_size,
    p.min_experience_years,
    p.work_type,
    p.location,
    p.cover_image_url,
    p.images,
    p.video_url,
    p.tags,
    p.requirements,
    p.deliverables,
    p.payment_terms,
    p.contract_type,
    p.workflow_steps,
    p.files,
    p.view_count,
    p.bookmark_count,
    p.proposal_count,
    p.application_count,
    p.is_featured,
    p.is_urgent,
    p.is_remote_friendly,
    p.visibility,
    p.created_at,
    p.updated_at,
    p.published_at,
    p.started_at,
    p.closed_at,
    COALESCE(ps.view_count, 0) AS stats_view_count,
    COALESCE(ps.bookmark_count, 0) AS stats_bookmark_count,
    ps.last_viewed_at,
    ( SELECT count(*) AS count
           FROM public.project_proposals
          WHERE (project_proposals.project_id = p.id)) AS proposal_count_calc,
    ( SELECT count(*) AS count
           FROM public.project_applications
          WHERE (project_applications.project_id = p.id)) AS application_count_calc,
    ( SELECT count(*) AS count
           FROM public.project_members
          WHERE ((project_members.project_id = p.id) AND (project_members.status = 'active'::text))) AS member_count,
    ( SELECT count(*) AS count
           FROM public.project_comments
          WHERE ((project_comments.project_id = p.id) AND (project_comments.is_deleted = false))) AS comment_count
   FROM (public.projects p
     LEFT JOIN public.project_stats ps ON ((p.id = ps.project_id)));


CREATE OR REPLACE FUNCTION public.set_response_date()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.response_date = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.set_viewed_date()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.viewed_date = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.system_leave_message(p_room_id uuid, p_user_id uuid, p_user_name text DEFAULT ''::text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
begin
  insert into public.chat_messages (room_id, sender_id, content, type, created_at)
  values (
    p_room_id,
    p_user_id,
    concat(coalesce(nullif(trim(p_user_name), ''), ''), ' .'),
    'system',
    timezone('utc', now())
  );
end;
$function$
;

CREATE OR REPLACE FUNCTION public.toggle_lounge_comment_like(p_user_id uuid, p_comment_id uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_exists BOOLEAN;
BEGIN
  -- Check if like already exists
  SELECT EXISTS (
    SELECT 1 FROM lounge_comment_likes
    WHERE user_id = p_user_id AND comment_id = p_comment_id
  ) INTO v_exists;

  IF v_exists THEN
    -- Unlike: Delete like record
    DELETE FROM lounge_comment_likes
    WHERE user_id = p_user_id AND comment_id = p_comment_id;

    -- Decrement like_count (defensive: prevent negative values)
    UPDATE lounge_comments
    SET like_count = GREATEST(like_count - 1, 0)
    WHERE id = p_comment_id;

    RETURN FALSE; -- Unliked
  ELSE
    -- Like: Insert like record
    INSERT INTO lounge_comment_likes (user_id, comment_id)
    VALUES (p_user_id, p_comment_id);

    -- Increment like_count
    UPDATE lounge_comments
    SET like_count = like_count + 1
    WHERE id = p_comment_id;

    RETURN TRUE; -- Liked
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.toggle_lounge_like(p_user_id uuid, p_project_id uuid DEFAULT NULL::uuid, p_collaboration_id uuid DEFAULT NULL::uuid)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_like public.lounge_likes%ROWTYPE;
BEGIN
  -- Validate input: must have exactly one entity ID
  IF (p_project_id IS NULL AND p_collaboration_id IS NULL) OR
     (p_project_id IS NOT NULL AND p_collaboration_id IS NOT NULL) THEN
    RAISE EXCEPTION 'Must provide exactly one of project_id or collaboration_id';
  END IF;

  -- Fetch existing like (active or canceled)
  SELECT *
    INTO v_like
    FROM public.lounge_likes
   WHERE user_id = p_user_id
     AND (
       (project_id = p_project_id AND p_project_id IS NOT NULL) OR
       (collaboration_id = p_collaboration_id AND p_collaboration_id IS NOT NULL)
     )
   LIMIT 1;

  IF FOUND THEN
    IF v_like.is_canceled THEN
      -- Re-like: reactivate without changing created_at
      UPDATE public.lounge_likes
         SET is_canceled = FALSE
       WHERE id = v_like.id;
      RETURN TRUE;
    ELSE
      -- Cancel like
      UPDATE public.lounge_likes
         SET is_canceled = TRUE
       WHERE id = v_like.id;
      RETURN FALSE;
    END IF;
  ELSE
    -- First like
    INSERT INTO public.lounge_likes (user_id, project_id, collaboration_id, is_canceled)
    VALUES (p_user_id, p_project_id, p_collaboration_id, FALSE);
    RETURN TRUE;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.toggle_lounge_like(p_user_id uuid, p_project_id uuid DEFAULT NULL::uuid, p_collaboration_id uuid DEFAULT NULL::uuid, p_actor_role text DEFAULT NULL::text, p_actor_profile_id uuid DEFAULT NULL::uuid, p_actor_name text DEFAULT NULL::text, p_actor_avatar_url text DEFAULT NULL::text)
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_like public.lounge_likes%ROWTYPE;
BEGIN
  --  : project_id  collaboration_id    
  IF (p_project_id IS NULL AND p_collaboration_id IS NULL) OR
     (p_project_id IS NOT NULL AND p_collaboration_id IS NOT NULL) THEN
    RAISE EXCEPTION 'Must provide exactly one of project_id or collaboration_id';
  END IF;

  --    (   )
  SELECT *
    INTO v_like
    FROM public.lounge_likes
   WHERE user_id = p_user_id
     AND (
       (project_id = p_project_id AND p_project_id IS NOT NULL) OR
       (collaboration_id = p_collaboration_id AND p_collaboration_id IS NOT NULL)
     )
   LIMIT 1;

  IF FOUND THEN
    IF v_like.is_canceled THEN
      -- : actor   
      UPDATE public.lounge_likes
         SET is_canceled = FALSE,
             actor_role = COALESCE(p_actor_role, v_like.actor_role),
             actor_profile_id = COALESCE(p_actor_profile_id, v_like.actor_profile_id),
             actor_name = COALESCE(p_actor_name, v_like.actor_name),
             actor_avatar_url = COALESCE(p_actor_avatar_url, v_like.actor_avatar_url)
       WHERE id = v_like.id;
      RETURN TRUE;
    ELSE
      --  
      UPDATE public.lounge_likes
         SET is_canceled = TRUE
       WHERE id = v_like.id;
      RETURN FALSE;
    END IF;
  ELSE
    --  : actor  
    INSERT INTO public.lounge_likes (
      user_id, project_id, collaboration_id, is_canceled,
      actor_role, actor_profile_id, actor_name, actor_avatar_url
    )
    VALUES (
      p_user_id, p_project_id, p_collaboration_id, FALSE,
      p_actor_role, p_actor_profile_id, p_actor_name, p_actor_avatar_url
    );
    RETURN TRUE;
  END IF;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_profile_artists_single_active()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if coalesce(new.is_active, true) then
    perform public.fn_assert_single_active_nonfan(new.profile_id);
  end if;
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_profile_brands_single_active()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if coalesce(new.is_active, true) then
    perform public.fn_assert_single_active_nonfan(new.profile_id);
  end if;
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_profile_creatives_single_active()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if coalesce(new.is_active, true) then
    perform public.fn_assert_single_active_nonfan(new.profile_id);
  end if;
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_update_role_on_artist_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF (TG_OP = 'INSERT' AND COALESCE(NEW.is_active, true)) OR
     (TG_OP = 'UPDATE' AND (OLD.is_active IS DISTINCT FROM NEW.is_active)) THEN
    PERFORM public.update_profiles_role(NEW.profile_id);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_update_role_on_brand_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF (TG_OP = 'INSERT' AND COALESCE(NEW.is_active, true)) OR
     (TG_OP = 'UPDATE' AND (OLD.is_active IS DISTINCT FROM NEW.is_active)) THEN
    PERFORM public.update_profiles_role(NEW.profile_id);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_update_role_on_creative_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF (TG_OP = 'INSERT' AND COALESCE(NEW.is_active, true)) OR
     (TG_OP = 'UPDATE' AND (OLD.is_active IS DISTINCT FROM NEW.is_active)) THEN
    PERFORM public.update_profiles_role(NEW.profile_id);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.trg_update_role_on_fan_change()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- is_active    
  IF (TG_OP = 'INSERT' AND COALESCE(NEW.is_active, true)) OR
     (TG_OP = 'UPDATE' AND (OLD.is_active IS DISTINCT FROM NEW.is_active)) THEN
    PERFORM public.update_profiles_role(NEW.profile_id);
  END IF;
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_chat_room_invitations_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_collaboration_bookmark_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.collaboration_id IS NOT NULL THEN
    INSERT INTO collaboration_stats (collaboration_id, bookmark_count)
    VALUES (NEW.collaboration_id, 1)
    ON CONFLICT (collaboration_id) 
    DO UPDATE SET 
      bookmark_count = collaboration_stats.bookmark_count + 1,
      updated_at = NOW();
  ELSIF TG_OP = 'DELETE' AND OLD.collaboration_id IS NOT NULL THEN
    UPDATE collaboration_stats
    SET bookmark_count = GREATEST(0, bookmark_count - 1),
        updated_at = NOW()
    WHERE collaboration_id = OLD.collaboration_id;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_current_team_size()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    UPDATE collaborations
    SET current_team_size = (
      SELECT COUNT(*)
      FROM collaboration_members
      WHERE collaboration_id = NEW.collaboration_id
        AND status = 'active'
    )
    WHERE id = NEW.collaboration_id;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE collaborations
    SET current_team_size = (
      SELECT COUNT(*)
      FROM collaboration_members
      WHERE collaboration_id = OLD.collaboration_id
        AND status = 'active'
    )
    WHERE id = OLD.collaboration_id;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_homepage_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_inquiry_username()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- username     
  IF NEW.username IS NULL OR NEW.username = '' THEN
    SELECT username INTO NEW.username
    FROM public.profiles
    WHERE id = NEW.user_id;
    
    -- username   nickname  
    IF NEW.username IS NULL OR NEW.username = '' THEN
      SELECT COALESCE(
        (SELECT nickname FROM public.profile_artists WHERE profile_id = NEW.user_id LIMIT 1),
        (SELECT nickname FROM public.profile_brands WHERE profile_id = NEW.user_id LIMIT 1),
        (SELECT nickname FROM public.profile_creatives WHERE profile_id = NEW.user_id LIMIT 1),
        (SELECT nickname FROM public.profile_fans WHERE profile_id = NEW.user_id LIMIT 1)
      ) INTO NEW.username;
    END IF;
  END IF;
  
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_profiles_role(p_user_id uuid)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  v_roles text[] := ARRAY[]::text[];
BEGIN
  --    
  IF EXISTS (
    SELECT 1 FROM public.profile_fans 
    WHERE profile_id = p_user_id AND is_active = true
  ) THEN
    v_roles := array_append(v_roles, 'fan');
  END IF;

  --    
  IF EXISTS (
    SELECT 1 FROM public.profile_brands 
    WHERE profile_id = p_user_id AND is_active = true
  ) THEN
    v_roles := array_append(v_roles, 'brand');
  END IF;

  --    
  IF EXISTS (
    SELECT 1 FROM public.profile_artists 
    WHERE profile_id = p_user_id AND is_active = true
  ) THEN
    v_roles := array_append(v_roles, 'artist');
  END IF;

  --    
  IF EXISTS (
    SELECT 1 FROM public.profile_creatives 
    WHERE profile_id = p_user_id AND is_active = true
  ) THEN
    v_roles := array_append(v_roles, 'creative');
  END IF;

  -- profiles   (role -> roles )
  UPDATE public.profiles
  SET roles = v_roles, updated_at = NOW()
  WHERE id = p_user_id;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_project_bookmark_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' AND NEW.project_id IS NOT NULL THEN
    INSERT INTO project_stats (project_id, bookmark_count)
    VALUES (NEW.project_id, 1)
    ON CONFLICT (project_id) 
    DO UPDATE SET 
      bookmark_count = project_stats.bookmark_count + 1,
      updated_at = NOW();
  ELSIF TG_OP = 'DELETE' AND OLD.project_id IS NOT NULL THEN
    UPDATE project_stats
    SET bookmark_count = GREATEST(0, bookmark_count - 1),
        updated_at = NOW()
    WHERE project_id = OLD.project_id;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_project_team_size()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  IF TG_OP = 'INSERT' OR TG_OP = 'UPDATE' THEN
    UPDATE projects
    SET current_team_size = (
      SELECT COUNT(*)
      FROM project_members
      WHERE project_id = NEW.project_id
        AND status = 'active'
    )
    WHERE id = NEW.project_id;
  ELSIF TG_OP = 'DELETE' THEN
    UPDATE projects
    SET current_team_size = (
      SELECT COUNT(*)
      FROM project_members
      WHERE project_id = OLD.project_id
        AND status = 'active'
    )
    WHERE id = OLD.project_id;
  END IF;
  RETURN NULL;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_reviews_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_user_role()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  incoming_roles text[] := ARRAY[]::text[];
  current_roles text[] := ARRAY[]::text[];
  result_roles text[] := ARRAY[]::text[];
  role text;
  has_fan boolean := false;
  nonfan_role text := NULL;
  incoming_nonfan text := NULL;
  fan_label constant text := 'fan';
  nonfan_labels constant text[] := ARRAY['brand', 'artist', 'creative'];
BEGIN
  IF TG_NARGS > 0 THEN
    BEGIN
      incoming_roles := COALESCE(TG_ARGV[0]::text[], ARRAY[]::text[]);
    EXCEPTION
      WHEN others THEN
        incoming_roles := ARRAY[TG_ARGV[0]];
    END;
  END IF;

  SELECT array_remove(COALESCE(roles, ARRAY[]::text[]), 'customer')
  INTO current_roles
  FROM public.profiles
  WHERE id = NEW.profile_id
  FOR UPDATE;

  has_fan := fan_label = ANY(current_roles);
  SELECT r INTO nonfan_role
  FROM unnest(current_roles) AS r
  WHERE r = ANY(nonfan_labels)
  LIMIT 1;

  IF array_length(incoming_roles, 1) IS NOT NULL THEN
    FOREACH role IN ARRAY incoming_roles LOOP
      IF role = fan_label THEN
        has_fan := true;
      ELSIF role = ANY(nonfan_labels) THEN
        incoming_nonfan := role;
      END IF;
    END LOOP;
  END IF;

  IF incoming_nonfan IS NOT NULL THEN
    nonfan_role := incoming_nonfan;
  END IF;

  IF has_fan THEN
    result_roles := result_roles || fan_label;
  END IF;

  IF nonfan_role IS NOT NULL THEN
    result_roles := result_roles || nonfan_role;
  END IF;

  UPDATE public.profiles
  SET roles = result_roles,
      updated_at = NOW()
  WHERE id = NEW.profile_id;

  RETURN NEW;
END;
$function$
;

create or replace view "public"."user_all_notifications" as  SELECT pp.id,
    'proposal'::text AS notification_type,
    pp.project_id AS activity_id,
    'project'::text AS activity_type,
    pp.sender_id,
    pp.receiver_id,
    pp.status,
    pp.message,
    pp.sent_date,
    pp.viewed_date,
    pp.response_date,
    pp.is_read,
    pp.is_starred,
    pp.created_at,
    p.title AS activity_title,
    p.cover_image_url AS activity_image,
    sender.nickname AS sender_name,
    sender.avatar_url AS sender_avatar,
    pp.budget_range AS offered_budget,
    pp.duration AS offered_timeline,
    pp."position" AS offered_role,
    NULL::text AS question,
    NULL::text AS compensation
   FROM ((public.project_proposals pp
     JOIN public.projects p ON ((pp.project_id = p.id)))
     JOIN public.profiles sender ON ((pp.sender_id = sender.id)))
UNION ALL
 SELECT ci.id,
    'invitation'::text AS notification_type,
    ci.collaboration_id AS activity_id,
    'collaboration'::text AS activity_type,
    ci.inviter_id AS sender_id,
    ci.invitee_id AS receiver_id,
    ci.status,
    ci.message,
    ci.sent_date,
    ci.viewed_date,
    ci.response_date,
    ci.is_read,
    ci.is_starred,
    ci.created_at,
    c.title AS activity_title,
    c.cover_image_url AS activity_image,
    inviter.nickname AS sender_name,
    inviter.avatar_url AS sender_avatar,
    NULL::text AS offered_budget,
    NULL::text AS offered_timeline,
    ci."position" AS offered_role,
    ci.question,
    ci.compensation
   FROM ((public.collaboration_invitations ci
     JOIN public.collaborations c ON ((ci.collaboration_id = c.id)))
     JOIN public.profiles inviter ON ((ci.inviter_id = inviter.id)))
UNION ALL
 SELECT pa.id,
    'application'::text AS notification_type,
    pa.project_id AS activity_id,
    'project'::text AS activity_type,
    pa.applicant_id AS sender_id,
    p.created_by AS receiver_id,
    pa.status,
    pa.cover_letter AS message,
    pa.created_at AS sent_date,
    pa.reviewed_date AS viewed_date,
    pa.response_date,
    pa.is_read,
    false AS is_starred,
    pa.created_at,
    p.title AS activity_title,
    p.cover_image_url AS activity_image,
    applicant.nickname AS sender_name,
    applicant.avatar_url AS sender_avatar,
    NULL::text AS offered_budget,
    NULL::text AS offered_timeline,
    NULL::text AS offered_role,
    NULL::text AS question,
    NULL::text AS compensation
   FROM ((public.project_applications pa
     JOIN public.projects p ON ((pa.project_id = p.id)))
     JOIN public.profiles applicant ON ((pa.applicant_id = applicant.id)))
UNION ALL
 SELECT ca.id,
    'application'::text AS notification_type,
    ca.collaboration_id AS activity_id,
    'collaboration'::text AS activity_type,
    ca.applicant_id AS sender_id,
    c.created_by AS receiver_id,
    ca.status,
    ca.cover_letter AS message,
    ca.created_at AS sent_date,
    ca.reviewed_date AS viewed_date,
    ca.response_date,
    ca.is_read,
    false AS is_starred,
    ca.created_at,
    c.title AS activity_title,
    c.cover_image_url AS activity_image,
    applicant.nickname AS sender_name,
    applicant.avatar_url AS sender_avatar,
    NULL::text AS offered_budget,
    NULL::text AS offered_timeline,
    NULL::text AS offered_role,
    NULL::text AS question,
    NULL::text AS compensation
   FROM ((public.collaboration_applications ca
     JOIN public.collaborations c ON ((ca.collaboration_id = c.id)))
     JOIN public.profiles applicant ON ((ca.applicant_id = applicant.id)))
UNION ALL
 SELECT m.id,
    'message'::text AS notification_type,
    m.room_id AS activity_id,
    'chat'::text AS activity_type,
    m.sender_id,
    p.user_id AS receiver_id,
    'sent'::text AS status,
    m.content AS message,
    m.created_at AS sent_date,
    NULL::timestamp without time zone AS viewed_date,
    NULL::timestamp without time zone AS response_date,
        CASE
            WHEN (m.created_at <= p.last_read_at) THEN true
            ELSE false
        END AS is_read,
    false AS is_starred,
    m.created_at,
    COALESCE(r.title, ''::text) AS activity_title,
    NULL::text AS activity_image,
    sender.nickname AS sender_name,
    sender.avatar_url AS sender_avatar,
    NULL::text AS offered_budget,
    NULL::text AS offered_timeline,
    NULL::text AS offered_role,
    NULL::text AS question,
    NULL::text AS compensation
   FROM (((public.chat_messages m
     JOIN public.chat_rooms r ON ((m.room_id = r.id)))
     JOIN public.chat_participants p ON ((m.room_id = p.room_id)))
     JOIN public.profiles sender ON ((m.sender_id = sender.id)))
  WHERE (m.sender_id <> p.user_id);


CREATE OR REPLACE FUNCTION public.user_in_room(target_room_id uuid, target_user_id uuid)
 RETURNS boolean
 LANGUAGE sql
 SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
    select exists (
        select 1
        from public.chat_participants
        where room_id = target_room_id
          and user_id = target_user_id
    );
$function$
;

create or replace view "public"."admin_all_users" as  SELECT 'artist'::text AS user_type,
    pa.profile_id,
    pa.artist_name AS display_name,
    pa.activity_field AS category,
    pa.created_at,
    'approved'::text AS approval_status,
    public.get_auth_email(pa.profile_id) AS email
   FROM public.profile_artists pa
UNION ALL
 SELECT 'brand'::text AS user_type,
    pb.profile_id,
    pb.brand_name AS display_name,
    pb.activity_field AS category,
    pb.created_at,
    pb.approval_status,
    public.get_auth_email(pb.profile_id) AS email
   FROM public.profile_brands pb
UNION ALL
 SELECT 'creative'::text AS user_type,
    pc.profile_id,
    pc.nickname AS display_name,
    NULL::text AS category,
    pc.created_at,
    'approved'::text AS approval_status,
    public.get_auth_email(pc.profile_id) AS email
   FROM public.profile_creatives pc
UNION ALL
 SELECT 'fan'::text AS user_type,
    pf.profile_id,
    pp.nickname AS display_name,
    NULL::text AS category,
    pf.created_at,
    'approved'::text AS approval_status,
    public.get_auth_email(pf.profile_id) AS email
   FROM (public.profile_fans pf
     JOIN public.profiles pp ON ((pf.profile_id = pp.id)));


grant delete on table "public"."activity_field_keywords" to "anon";

grant insert on table "public"."activity_field_keywords" to "anon";

grant references on table "public"."activity_field_keywords" to "anon";

grant select on table "public"."activity_field_keywords" to "anon";

grant trigger on table "public"."activity_field_keywords" to "anon";

grant truncate on table "public"."activity_field_keywords" to "anon";

grant update on table "public"."activity_field_keywords" to "anon";

grant delete on table "public"."activity_field_keywords" to "authenticated";

grant insert on table "public"."activity_field_keywords" to "authenticated";

grant references on table "public"."activity_field_keywords" to "authenticated";

grant select on table "public"."activity_field_keywords" to "authenticated";

grant trigger on table "public"."activity_field_keywords" to "authenticated";

grant truncate on table "public"."activity_field_keywords" to "authenticated";

grant update on table "public"."activity_field_keywords" to "authenticated";

grant delete on table "public"."activity_field_keywords" to "service_role";

grant insert on table "public"."activity_field_keywords" to "service_role";

grant references on table "public"."activity_field_keywords" to "service_role";

grant select on table "public"."activity_field_keywords" to "service_role";

grant trigger on table "public"."activity_field_keywords" to "service_role";

grant truncate on table "public"."activity_field_keywords" to "service_role";

grant update on table "public"."activity_field_keywords" to "service_role";

grant delete on table "public"."admin_activity_logs" to "anon";

grant insert on table "public"."admin_activity_logs" to "anon";

grant references on table "public"."admin_activity_logs" to "anon";

grant select on table "public"."admin_activity_logs" to "anon";

grant trigger on table "public"."admin_activity_logs" to "anon";

grant truncate on table "public"."admin_activity_logs" to "anon";

grant update on table "public"."admin_activity_logs" to "anon";

grant delete on table "public"."admin_activity_logs" to "authenticated";

grant insert on table "public"."admin_activity_logs" to "authenticated";

grant references on table "public"."admin_activity_logs" to "authenticated";

grant select on table "public"."admin_activity_logs" to "authenticated";

grant trigger on table "public"."admin_activity_logs" to "authenticated";

grant truncate on table "public"."admin_activity_logs" to "authenticated";

grant update on table "public"."admin_activity_logs" to "authenticated";

grant delete on table "public"."admin_activity_logs" to "service_role";

grant insert on table "public"."admin_activity_logs" to "service_role";

grant references on table "public"."admin_activity_logs" to "service_role";

grant select on table "public"."admin_activity_logs" to "service_role";

grant trigger on table "public"."admin_activity_logs" to "service_role";

grant truncate on table "public"."admin_activity_logs" to "service_role";

grant update on table "public"."admin_activity_logs" to "service_role";

grant delete on table "public"."admins" to "anon";

grant insert on table "public"."admins" to "anon";

grant references on table "public"."admins" to "anon";

grant select on table "public"."admins" to "anon";

grant trigger on table "public"."admins" to "anon";

grant truncate on table "public"."admins" to "anon";

grant update on table "public"."admins" to "anon";

grant delete on table "public"."admins" to "authenticated";

grant insert on table "public"."admins" to "authenticated";

grant references on table "public"."admins" to "authenticated";

grant select on table "public"."admins" to "authenticated";

grant trigger on table "public"."admins" to "authenticated";

grant truncate on table "public"."admins" to "authenticated";

grant update on table "public"."admins" to "authenticated";

grant delete on table "public"."admins" to "service_role";

grant insert on table "public"."admins" to "service_role";

grant references on table "public"."admins" to "service_role";

grant select on table "public"."admins" to "service_role";

grant trigger on table "public"."admins" to "service_role";

grant truncate on table "public"."admins" to "service_role";

grant update on table "public"."admins" to "service_role";

grant delete on table "public"."badges" to "anon";

grant insert on table "public"."badges" to "anon";

grant references on table "public"."badges" to "anon";

grant select on table "public"."badges" to "anon";

grant trigger on table "public"."badges" to "anon";

grant truncate on table "public"."badges" to "anon";

grant update on table "public"."badges" to "anon";

grant delete on table "public"."badges" to "authenticated";

grant insert on table "public"."badges" to "authenticated";

grant references on table "public"."badges" to "authenticated";

grant select on table "public"."badges" to "authenticated";

grant trigger on table "public"."badges" to "authenticated";

grant truncate on table "public"."badges" to "authenticated";

grant update on table "public"."badges" to "authenticated";

grant delete on table "public"."badges" to "service_role";

grant insert on table "public"."badges" to "service_role";

grant references on table "public"."badges" to "service_role";

grant select on table "public"."badges" to "service_role";

grant trigger on table "public"."badges" to "service_role";

grant truncate on table "public"."badges" to "service_role";

grant update on table "public"."badges" to "service_role";

grant delete on table "public"."chat_messages" to "anon";

grant insert on table "public"."chat_messages" to "anon";

grant references on table "public"."chat_messages" to "anon";

grant select on table "public"."chat_messages" to "anon";

grant trigger on table "public"."chat_messages" to "anon";

grant truncate on table "public"."chat_messages" to "anon";

grant update on table "public"."chat_messages" to "anon";

grant delete on table "public"."chat_messages" to "authenticated";

grant insert on table "public"."chat_messages" to "authenticated";

grant references on table "public"."chat_messages" to "authenticated";

grant select on table "public"."chat_messages" to "authenticated";

grant trigger on table "public"."chat_messages" to "authenticated";

grant truncate on table "public"."chat_messages" to "authenticated";

grant update on table "public"."chat_messages" to "authenticated";

grant delete on table "public"."chat_messages" to "service_role";

grant insert on table "public"."chat_messages" to "service_role";

grant references on table "public"."chat_messages" to "service_role";

grant select on table "public"."chat_messages" to "service_role";

grant trigger on table "public"."chat_messages" to "service_role";

grant truncate on table "public"."chat_messages" to "service_role";

grant update on table "public"."chat_messages" to "service_role";

grant delete on table "public"."chat_participants" to "anon";

grant insert on table "public"."chat_participants" to "anon";

grant references on table "public"."chat_participants" to "anon";

grant select on table "public"."chat_participants" to "anon";

grant trigger on table "public"."chat_participants" to "anon";

grant truncate on table "public"."chat_participants" to "anon";

grant update on table "public"."chat_participants" to "anon";

grant delete on table "public"."chat_participants" to "authenticated";

grant insert on table "public"."chat_participants" to "authenticated";

grant references on table "public"."chat_participants" to "authenticated";

grant select on table "public"."chat_participants" to "authenticated";

grant trigger on table "public"."chat_participants" to "authenticated";

grant truncate on table "public"."chat_participants" to "authenticated";

grant update on table "public"."chat_participants" to "authenticated";

grant delete on table "public"."chat_participants" to "service_role";

grant insert on table "public"."chat_participants" to "service_role";

grant references on table "public"."chat_participants" to "service_role";

grant select on table "public"."chat_participants" to "service_role";

grant trigger on table "public"."chat_participants" to "service_role";

grant truncate on table "public"."chat_participants" to "service_role";

grant update on table "public"."chat_participants" to "service_role";

grant delete on table "public"."chat_room_invitations" to "anon";

grant insert on table "public"."chat_room_invitations" to "anon";

grant references on table "public"."chat_room_invitations" to "anon";

grant select on table "public"."chat_room_invitations" to "anon";

grant trigger on table "public"."chat_room_invitations" to "anon";

grant truncate on table "public"."chat_room_invitations" to "anon";

grant update on table "public"."chat_room_invitations" to "anon";

grant delete on table "public"."chat_room_invitations" to "authenticated";

grant insert on table "public"."chat_room_invitations" to "authenticated";

grant references on table "public"."chat_room_invitations" to "authenticated";

grant select on table "public"."chat_room_invitations" to "authenticated";

grant trigger on table "public"."chat_room_invitations" to "authenticated";

grant truncate on table "public"."chat_room_invitations" to "authenticated";

grant update on table "public"."chat_room_invitations" to "authenticated";

grant delete on table "public"."chat_room_invitations" to "service_role";

grant insert on table "public"."chat_room_invitations" to "service_role";

grant references on table "public"."chat_room_invitations" to "service_role";

grant select on table "public"."chat_room_invitations" to "service_role";

grant trigger on table "public"."chat_room_invitations" to "service_role";

grant truncate on table "public"."chat_room_invitations" to "service_role";

grant update on table "public"."chat_room_invitations" to "service_role";

grant delete on table "public"."chat_rooms" to "anon";

grant insert on table "public"."chat_rooms" to "anon";

grant references on table "public"."chat_rooms" to "anon";

grant select on table "public"."chat_rooms" to "anon";

grant trigger on table "public"."chat_rooms" to "anon";

grant truncate on table "public"."chat_rooms" to "anon";

grant update on table "public"."chat_rooms" to "anon";

grant delete on table "public"."chat_rooms" to "authenticated";

grant insert on table "public"."chat_rooms" to "authenticated";

grant references on table "public"."chat_rooms" to "authenticated";

grant select on table "public"."chat_rooms" to "authenticated";

grant trigger on table "public"."chat_rooms" to "authenticated";

grant truncate on table "public"."chat_rooms" to "authenticated";

grant update on table "public"."chat_rooms" to "authenticated";

grant delete on table "public"."chat_rooms" to "service_role";

grant insert on table "public"."chat_rooms" to "service_role";

grant references on table "public"."chat_rooms" to "service_role";

grant select on table "public"."chat_rooms" to "service_role";

grant trigger on table "public"."chat_rooms" to "service_role";

grant truncate on table "public"."chat_rooms" to "service_role";

grant update on table "public"."chat_rooms" to "service_role";

grant delete on table "public"."collaboration_applications" to "anon";

grant insert on table "public"."collaboration_applications" to "anon";

grant references on table "public"."collaboration_applications" to "anon";

grant select on table "public"."collaboration_applications" to "anon";

grant trigger on table "public"."collaboration_applications" to "anon";

grant truncate on table "public"."collaboration_applications" to "anon";

grant update on table "public"."collaboration_applications" to "anon";

grant delete on table "public"."collaboration_applications" to "authenticated";

grant insert on table "public"."collaboration_applications" to "authenticated";

grant references on table "public"."collaboration_applications" to "authenticated";

grant select on table "public"."collaboration_applications" to "authenticated";

grant trigger on table "public"."collaboration_applications" to "authenticated";

grant truncate on table "public"."collaboration_applications" to "authenticated";

grant update on table "public"."collaboration_applications" to "authenticated";

grant delete on table "public"."collaboration_applications" to "service_role";

grant insert on table "public"."collaboration_applications" to "service_role";

grant references on table "public"."collaboration_applications" to "service_role";

grant select on table "public"."collaboration_applications" to "service_role";

grant trigger on table "public"."collaboration_applications" to "service_role";

grant truncate on table "public"."collaboration_applications" to "service_role";

grant update on table "public"."collaboration_applications" to "service_role";

grant delete on table "public"."collaboration_invitations" to "anon";

grant insert on table "public"."collaboration_invitations" to "anon";

grant references on table "public"."collaboration_invitations" to "anon";

grant select on table "public"."collaboration_invitations" to "anon";

grant trigger on table "public"."collaboration_invitations" to "anon";

grant truncate on table "public"."collaboration_invitations" to "anon";

grant update on table "public"."collaboration_invitations" to "anon";

grant delete on table "public"."collaboration_invitations" to "authenticated";

grant insert on table "public"."collaboration_invitations" to "authenticated";

grant references on table "public"."collaboration_invitations" to "authenticated";

grant select on table "public"."collaboration_invitations" to "authenticated";

grant trigger on table "public"."collaboration_invitations" to "authenticated";

grant truncate on table "public"."collaboration_invitations" to "authenticated";

grant update on table "public"."collaboration_invitations" to "authenticated";

grant delete on table "public"."collaboration_invitations" to "service_role";

grant insert on table "public"."collaboration_invitations" to "service_role";

grant references on table "public"."collaboration_invitations" to "service_role";

grant select on table "public"."collaboration_invitations" to "service_role";

grant trigger on table "public"."collaboration_invitations" to "service_role";

grant truncate on table "public"."collaboration_invitations" to "service_role";

grant update on table "public"."collaboration_invitations" to "service_role";

grant delete on table "public"."collaboration_members" to "anon";

grant insert on table "public"."collaboration_members" to "anon";

grant references on table "public"."collaboration_members" to "anon";

grant select on table "public"."collaboration_members" to "anon";

grant trigger on table "public"."collaboration_members" to "anon";

grant truncate on table "public"."collaboration_members" to "anon";

grant update on table "public"."collaboration_members" to "anon";

grant delete on table "public"."collaboration_members" to "authenticated";

grant insert on table "public"."collaboration_members" to "authenticated";

grant references on table "public"."collaboration_members" to "authenticated";

grant select on table "public"."collaboration_members" to "authenticated";

grant trigger on table "public"."collaboration_members" to "authenticated";

grant truncate on table "public"."collaboration_members" to "authenticated";

grant update on table "public"."collaboration_members" to "authenticated";

grant delete on table "public"."collaboration_members" to "service_role";

grant insert on table "public"."collaboration_members" to "service_role";

grant references on table "public"."collaboration_members" to "service_role";

grant select on table "public"."collaboration_members" to "service_role";

grant trigger on table "public"."collaboration_members" to "service_role";

grant truncate on table "public"."collaboration_members" to "service_role";

grant update on table "public"."collaboration_members" to "service_role";

grant delete on table "public"."collaboration_stats" to "anon";

grant insert on table "public"."collaboration_stats" to "anon";

grant references on table "public"."collaboration_stats" to "anon";

grant select on table "public"."collaboration_stats" to "anon";

grant trigger on table "public"."collaboration_stats" to "anon";

grant truncate on table "public"."collaboration_stats" to "anon";

grant update on table "public"."collaboration_stats" to "anon";

grant delete on table "public"."collaboration_stats" to "authenticated";

grant insert on table "public"."collaboration_stats" to "authenticated";

grant references on table "public"."collaboration_stats" to "authenticated";

grant select on table "public"."collaboration_stats" to "authenticated";

grant trigger on table "public"."collaboration_stats" to "authenticated";

grant truncate on table "public"."collaboration_stats" to "authenticated";

grant update on table "public"."collaboration_stats" to "authenticated";

grant delete on table "public"."collaboration_stats" to "service_role";

grant insert on table "public"."collaboration_stats" to "service_role";

grant references on table "public"."collaboration_stats" to "service_role";

grant select on table "public"."collaboration_stats" to "service_role";

grant trigger on table "public"."collaboration_stats" to "service_role";

grant truncate on table "public"."collaboration_stats" to "service_role";

grant update on table "public"."collaboration_stats" to "service_role";

grant delete on table "public"."collaborations" to "anon";

grant insert on table "public"."collaborations" to "anon";

grant references on table "public"."collaborations" to "anon";

grant select on table "public"."collaborations" to "anon";

grant trigger on table "public"."collaborations" to "anon";

grant truncate on table "public"."collaborations" to "anon";

grant update on table "public"."collaborations" to "anon";

grant delete on table "public"."collaborations" to "authenticated";

grant insert on table "public"."collaborations" to "authenticated";

grant references on table "public"."collaborations" to "authenticated";

grant select on table "public"."collaborations" to "authenticated";

grant trigger on table "public"."collaborations" to "authenticated";

grant truncate on table "public"."collaborations" to "authenticated";

grant update on table "public"."collaborations" to "authenticated";

grant delete on table "public"."collaborations" to "service_role";

grant insert on table "public"."collaborations" to "service_role";

grant references on table "public"."collaborations" to "service_role";

grant select on table "public"."collaborations" to "service_role";

grant trigger on table "public"."collaborations" to "service_role";

grant truncate on table "public"."collaborations" to "service_role";

grant update on table "public"."collaborations" to "service_role";

grant delete on table "public"."homepage_slider_images" to "anon";

grant insert on table "public"."homepage_slider_images" to "anon";

grant references on table "public"."homepage_slider_images" to "anon";

grant select on table "public"."homepage_slider_images" to "anon";

grant trigger on table "public"."homepage_slider_images" to "anon";

grant truncate on table "public"."homepage_slider_images" to "anon";

grant update on table "public"."homepage_slider_images" to "anon";

grant delete on table "public"."homepage_slider_images" to "authenticated";

grant insert on table "public"."homepage_slider_images" to "authenticated";

grant references on table "public"."homepage_slider_images" to "authenticated";

grant select on table "public"."homepage_slider_images" to "authenticated";

grant trigger on table "public"."homepage_slider_images" to "authenticated";

grant truncate on table "public"."homepage_slider_images" to "authenticated";

grant update on table "public"."homepage_slider_images" to "authenticated";

grant delete on table "public"."homepage_slider_images" to "service_role";

grant insert on table "public"."homepage_slider_images" to "service_role";

grant references on table "public"."homepage_slider_images" to "service_role";

grant select on table "public"."homepage_slider_images" to "service_role";

grant trigger on table "public"."homepage_slider_images" to "service_role";

grant truncate on table "public"."homepage_slider_images" to "service_role";

grant update on table "public"."homepage_slider_images" to "service_role";

grant delete on table "public"."homepage_trending_projects" to "anon";

grant insert on table "public"."homepage_trending_projects" to "anon";

grant references on table "public"."homepage_trending_projects" to "anon";

grant select on table "public"."homepage_trending_projects" to "anon";

grant trigger on table "public"."homepage_trending_projects" to "anon";

grant truncate on table "public"."homepage_trending_projects" to "anon";

grant update on table "public"."homepage_trending_projects" to "anon";

grant delete on table "public"."homepage_trending_projects" to "authenticated";

grant insert on table "public"."homepage_trending_projects" to "authenticated";

grant references on table "public"."homepage_trending_projects" to "authenticated";

grant select on table "public"."homepage_trending_projects" to "authenticated";

grant trigger on table "public"."homepage_trending_projects" to "authenticated";

grant truncate on table "public"."homepage_trending_projects" to "authenticated";

grant update on table "public"."homepage_trending_projects" to "authenticated";

grant delete on table "public"."homepage_trending_projects" to "service_role";

grant insert on table "public"."homepage_trending_projects" to "service_role";

grant references on table "public"."homepage_trending_projects" to "service_role";

grant select on table "public"."homepage_trending_projects" to "service_role";

grant trigger on table "public"."homepage_trending_projects" to "service_role";

grant truncate on table "public"."homepage_trending_projects" to "service_role";

grant update on table "public"."homepage_trending_projects" to "service_role";

grant delete on table "public"."inquiries" to "anon";

grant insert on table "public"."inquiries" to "anon";

grant references on table "public"."inquiries" to "anon";

grant select on table "public"."inquiries" to "anon";

grant trigger on table "public"."inquiries" to "anon";

grant truncate on table "public"."inquiries" to "anon";

grant update on table "public"."inquiries" to "anon";

grant delete on table "public"."inquiries" to "authenticated";

grant insert on table "public"."inquiries" to "authenticated";

grant references on table "public"."inquiries" to "authenticated";

grant select on table "public"."inquiries" to "authenticated";

grant trigger on table "public"."inquiries" to "authenticated";

grant truncate on table "public"."inquiries" to "authenticated";

grant update on table "public"."inquiries" to "authenticated";

grant delete on table "public"."inquiries" to "service_role";

grant insert on table "public"."inquiries" to "service_role";

grant references on table "public"."inquiries" to "service_role";

grant select on table "public"."inquiries" to "service_role";

grant trigger on table "public"."inquiries" to "service_role";

grant truncate on table "public"."inquiries" to "service_role";

grant update on table "public"."inquiries" to "service_role";

grant delete on table "public"."lounge_bookmarks" to "anon";

grant insert on table "public"."lounge_bookmarks" to "anon";

grant references on table "public"."lounge_bookmarks" to "anon";

grant select on table "public"."lounge_bookmarks" to "anon";

grant trigger on table "public"."lounge_bookmarks" to "anon";

grant truncate on table "public"."lounge_bookmarks" to "anon";

grant update on table "public"."lounge_bookmarks" to "anon";

grant delete on table "public"."lounge_bookmarks" to "authenticated";

grant insert on table "public"."lounge_bookmarks" to "authenticated";

grant references on table "public"."lounge_bookmarks" to "authenticated";

grant select on table "public"."lounge_bookmarks" to "authenticated";

grant trigger on table "public"."lounge_bookmarks" to "authenticated";

grant truncate on table "public"."lounge_bookmarks" to "authenticated";

grant update on table "public"."lounge_bookmarks" to "authenticated";

grant delete on table "public"."lounge_bookmarks" to "service_role";

grant insert on table "public"."lounge_bookmarks" to "service_role";

grant references on table "public"."lounge_bookmarks" to "service_role";

grant select on table "public"."lounge_bookmarks" to "service_role";

grant trigger on table "public"."lounge_bookmarks" to "service_role";

grant truncate on table "public"."lounge_bookmarks" to "service_role";

grant update on table "public"."lounge_bookmarks" to "service_role";

grant delete on table "public"."lounge_comment_likes" to "anon";

grant insert on table "public"."lounge_comment_likes" to "anon";

grant references on table "public"."lounge_comment_likes" to "anon";

grant select on table "public"."lounge_comment_likes" to "anon";

grant trigger on table "public"."lounge_comment_likes" to "anon";

grant truncate on table "public"."lounge_comment_likes" to "anon";

grant update on table "public"."lounge_comment_likes" to "anon";

grant delete on table "public"."lounge_comment_likes" to "authenticated";

grant insert on table "public"."lounge_comment_likes" to "authenticated";

grant references on table "public"."lounge_comment_likes" to "authenticated";

grant select on table "public"."lounge_comment_likes" to "authenticated";

grant trigger on table "public"."lounge_comment_likes" to "authenticated";

grant truncate on table "public"."lounge_comment_likes" to "authenticated";

grant update on table "public"."lounge_comment_likes" to "authenticated";

grant delete on table "public"."lounge_comment_likes" to "service_role";

grant insert on table "public"."lounge_comment_likes" to "service_role";

grant references on table "public"."lounge_comment_likes" to "service_role";

grant select on table "public"."lounge_comment_likes" to "service_role";

grant trigger on table "public"."lounge_comment_likes" to "service_role";

grant truncate on table "public"."lounge_comment_likes" to "service_role";

grant update on table "public"."lounge_comment_likes" to "service_role";

grant delete on table "public"."lounge_comments" to "anon";

grant insert on table "public"."lounge_comments" to "anon";

grant references on table "public"."lounge_comments" to "anon";

grant select on table "public"."lounge_comments" to "anon";

grant trigger on table "public"."lounge_comments" to "anon";

grant truncate on table "public"."lounge_comments" to "anon";

grant update on table "public"."lounge_comments" to "anon";

grant delete on table "public"."lounge_comments" to "authenticated";

grant insert on table "public"."lounge_comments" to "authenticated";

grant references on table "public"."lounge_comments" to "authenticated";

grant select on table "public"."lounge_comments" to "authenticated";

grant trigger on table "public"."lounge_comments" to "authenticated";

grant truncate on table "public"."lounge_comments" to "authenticated";

grant update on table "public"."lounge_comments" to "authenticated";

grant delete on table "public"."lounge_comments" to "service_role";

grant insert on table "public"."lounge_comments" to "service_role";

grant references on table "public"."lounge_comments" to "service_role";

grant select on table "public"."lounge_comments" to "service_role";

grant trigger on table "public"."lounge_comments" to "service_role";

grant truncate on table "public"."lounge_comments" to "service_role";

grant update on table "public"."lounge_comments" to "service_role";

grant delete on table "public"."lounge_likes" to "anon";

grant insert on table "public"."lounge_likes" to "anon";

grant references on table "public"."lounge_likes" to "anon";

grant select on table "public"."lounge_likes" to "anon";

grant trigger on table "public"."lounge_likes" to "anon";

grant truncate on table "public"."lounge_likes" to "anon";

grant update on table "public"."lounge_likes" to "anon";

grant delete on table "public"."lounge_likes" to "authenticated";

grant insert on table "public"."lounge_likes" to "authenticated";

grant references on table "public"."lounge_likes" to "authenticated";

grant select on table "public"."lounge_likes" to "authenticated";

grant trigger on table "public"."lounge_likes" to "authenticated";

grant truncate on table "public"."lounge_likes" to "authenticated";

grant update on table "public"."lounge_likes" to "authenticated";

grant delete on table "public"."lounge_likes" to "service_role";

grant insert on table "public"."lounge_likes" to "service_role";

grant references on table "public"."lounge_likes" to "service_role";

grant select on table "public"."lounge_likes" to "service_role";

grant trigger on table "public"."lounge_likes" to "service_role";

grant truncate on table "public"."lounge_likes" to "service_role";

grant update on table "public"."lounge_likes" to "service_role";

grant delete on table "public"."magazines" to "anon";

grant insert on table "public"."magazines" to "anon";

grant references on table "public"."magazines" to "anon";

grant select on table "public"."magazines" to "anon";

grant trigger on table "public"."magazines" to "anon";

grant truncate on table "public"."magazines" to "anon";

grant update on table "public"."magazines" to "anon";

grant delete on table "public"."magazines" to "authenticated";

grant insert on table "public"."magazines" to "authenticated";

grant references on table "public"."magazines" to "authenticated";

grant select on table "public"."magazines" to "authenticated";

grant trigger on table "public"."magazines" to "authenticated";

grant truncate on table "public"."magazines" to "authenticated";

grant update on table "public"."magazines" to "authenticated";

grant delete on table "public"."magazines" to "service_role";

grant insert on table "public"."magazines" to "service_role";

grant references on table "public"."magazines" to "service_role";

grant select on table "public"."magazines" to "service_role";

grant trigger on table "public"."magazines" to "service_role";

grant truncate on table "public"."magazines" to "service_role";

grant update on table "public"."magazines" to "service_role";

grant delete on table "public"."partner_stats" to "anon";

grant insert on table "public"."partner_stats" to "anon";

grant references on table "public"."partner_stats" to "anon";

grant select on table "public"."partner_stats" to "anon";

grant trigger on table "public"."partner_stats" to "anon";

grant truncate on table "public"."partner_stats" to "anon";

grant update on table "public"."partner_stats" to "anon";

grant delete on table "public"."partner_stats" to "authenticated";

grant insert on table "public"."partner_stats" to "authenticated";

grant references on table "public"."partner_stats" to "authenticated";

grant select on table "public"."partner_stats" to "authenticated";

grant trigger on table "public"."partner_stats" to "authenticated";

grant truncate on table "public"."partner_stats" to "authenticated";

grant update on table "public"."partner_stats" to "authenticated";

grant delete on table "public"."partner_stats" to "service_role";

grant insert on table "public"."partner_stats" to "service_role";

grant references on table "public"."partner_stats" to "service_role";

grant select on table "public"."partner_stats" to "service_role";

grant trigger on table "public"."partner_stats" to "service_role";

grant truncate on table "public"."partner_stats" to "service_role";

grant update on table "public"."partner_stats" to "service_role";

grant delete on table "public"."partnership_inquiries" to "anon";

grant insert on table "public"."partnership_inquiries" to "anon";

grant references on table "public"."partnership_inquiries" to "anon";

grant select on table "public"."partnership_inquiries" to "anon";

grant trigger on table "public"."partnership_inquiries" to "anon";

grant truncate on table "public"."partnership_inquiries" to "anon";

grant update on table "public"."partnership_inquiries" to "anon";

grant delete on table "public"."partnership_inquiries" to "authenticated";

grant insert on table "public"."partnership_inquiries" to "authenticated";

grant references on table "public"."partnership_inquiries" to "authenticated";

grant select on table "public"."partnership_inquiries" to "authenticated";

grant trigger on table "public"."partnership_inquiries" to "authenticated";

grant truncate on table "public"."partnership_inquiries" to "authenticated";

grant update on table "public"."partnership_inquiries" to "authenticated";

grant delete on table "public"."partnership_inquiries" to "service_role";

grant insert on table "public"."partnership_inquiries" to "service_role";

grant references on table "public"."partnership_inquiries" to "service_role";

grant select on table "public"."partnership_inquiries" to "service_role";

grant trigger on table "public"."partnership_inquiries" to "service_role";

grant truncate on table "public"."partnership_inquiries" to "service_role";

grant update on table "public"."partnership_inquiries" to "service_role";

grant delete on table "public"."profile_artists" to "anon";

grant insert on table "public"."profile_artists" to "anon";

grant references on table "public"."profile_artists" to "anon";

grant select on table "public"."profile_artists" to "anon";

grant trigger on table "public"."profile_artists" to "anon";

grant truncate on table "public"."profile_artists" to "anon";

grant update on table "public"."profile_artists" to "anon";

grant delete on table "public"."profile_artists" to "authenticated";

grant insert on table "public"."profile_artists" to "authenticated";

grant references on table "public"."profile_artists" to "authenticated";

grant select on table "public"."profile_artists" to "authenticated";

grant trigger on table "public"."profile_artists" to "authenticated";

grant truncate on table "public"."profile_artists" to "authenticated";

grant update on table "public"."profile_artists" to "authenticated";

grant delete on table "public"."profile_artists" to "service_role";

grant insert on table "public"."profile_artists" to "service_role";

grant references on table "public"."profile_artists" to "service_role";

grant select on table "public"."profile_artists" to "service_role";

grant trigger on table "public"."profile_artists" to "service_role";

grant truncate on table "public"."profile_artists" to "service_role";

grant update on table "public"."profile_artists" to "service_role";

grant delete on table "public"."profile_brands" to "anon";

grant insert on table "public"."profile_brands" to "anon";

grant references on table "public"."profile_brands" to "anon";

grant select on table "public"."profile_brands" to "anon";

grant trigger on table "public"."profile_brands" to "anon";

grant truncate on table "public"."profile_brands" to "anon";

grant update on table "public"."profile_brands" to "anon";

grant delete on table "public"."profile_brands" to "authenticated";

grant insert on table "public"."profile_brands" to "authenticated";

grant references on table "public"."profile_brands" to "authenticated";

grant select on table "public"."profile_brands" to "authenticated";

grant trigger on table "public"."profile_brands" to "authenticated";

grant truncate on table "public"."profile_brands" to "authenticated";

grant update on table "public"."profile_brands" to "authenticated";

grant delete on table "public"."profile_brands" to "service_role";

grant insert on table "public"."profile_brands" to "service_role";

grant references on table "public"."profile_brands" to "service_role";

grant select on table "public"."profile_brands" to "service_role";

grant trigger on table "public"."profile_brands" to "service_role";

grant truncate on table "public"."profile_brands" to "service_role";

grant update on table "public"."profile_brands" to "service_role";

grant delete on table "public"."profile_creatives" to "anon";

grant insert on table "public"."profile_creatives" to "anon";

grant references on table "public"."profile_creatives" to "anon";

grant select on table "public"."profile_creatives" to "anon";

grant trigger on table "public"."profile_creatives" to "anon";

grant truncate on table "public"."profile_creatives" to "anon";

grant update on table "public"."profile_creatives" to "anon";

grant delete on table "public"."profile_creatives" to "authenticated";

grant insert on table "public"."profile_creatives" to "authenticated";

grant references on table "public"."profile_creatives" to "authenticated";

grant select on table "public"."profile_creatives" to "authenticated";

grant trigger on table "public"."profile_creatives" to "authenticated";

grant truncate on table "public"."profile_creatives" to "authenticated";

grant update on table "public"."profile_creatives" to "authenticated";

grant delete on table "public"."profile_creatives" to "service_role";

grant insert on table "public"."profile_creatives" to "service_role";

grant references on table "public"."profile_creatives" to "service_role";

grant select on table "public"."profile_creatives" to "service_role";

grant trigger on table "public"."profile_creatives" to "service_role";

grant truncate on table "public"."profile_creatives" to "service_role";

grant update on table "public"."profile_creatives" to "service_role";

grant delete on table "public"."profile_fans" to "anon";

grant insert on table "public"."profile_fans" to "anon";

grant references on table "public"."profile_fans" to "anon";

grant select on table "public"."profile_fans" to "anon";

grant trigger on table "public"."profile_fans" to "anon";

grant truncate on table "public"."profile_fans" to "anon";

grant update on table "public"."profile_fans" to "anon";

grant delete on table "public"."profile_fans" to "authenticated";

grant insert on table "public"."profile_fans" to "authenticated";

grant references on table "public"."profile_fans" to "authenticated";

grant select on table "public"."profile_fans" to "authenticated";

grant trigger on table "public"."profile_fans" to "authenticated";

grant truncate on table "public"."profile_fans" to "authenticated";

grant update on table "public"."profile_fans" to "authenticated";

grant delete on table "public"."profile_fans" to "service_role";

grant insert on table "public"."profile_fans" to "service_role";

grant references on table "public"."profile_fans" to "service_role";

grant select on table "public"."profile_fans" to "service_role";

grant trigger on table "public"."profile_fans" to "service_role";

grant truncate on table "public"."profile_fans" to "service_role";

grant update on table "public"."profile_fans" to "service_role";

grant delete on table "public"."profiles" to "anon";

grant insert on table "public"."profiles" to "anon";

grant references on table "public"."profiles" to "anon";

grant select on table "public"."profiles" to "anon";

grant trigger on table "public"."profiles" to "anon";

grant truncate on table "public"."profiles" to "anon";

grant update on table "public"."profiles" to "anon";

grant delete on table "public"."profiles" to "authenticated";

grant insert on table "public"."profiles" to "authenticated";

grant references on table "public"."profiles" to "authenticated";

grant select on table "public"."profiles" to "authenticated";

grant trigger on table "public"."profiles" to "authenticated";

grant truncate on table "public"."profiles" to "authenticated";

grant update on table "public"."profiles" to "authenticated";

grant delete on table "public"."profiles" to "service_role";

grant insert on table "public"."profiles" to "service_role";

grant references on table "public"."profiles" to "service_role";

grant select on table "public"."profiles" to "service_role";

grant trigger on table "public"."profiles" to "service_role";

grant truncate on table "public"."profiles" to "service_role";

grant update on table "public"."profiles" to "service_role";

grant delete on table "public"."project_applications" to "anon";

grant insert on table "public"."project_applications" to "anon";

grant references on table "public"."project_applications" to "anon";

grant select on table "public"."project_applications" to "anon";

grant trigger on table "public"."project_applications" to "anon";

grant truncate on table "public"."project_applications" to "anon";

grant update on table "public"."project_applications" to "anon";

grant delete on table "public"."project_applications" to "authenticated";

grant insert on table "public"."project_applications" to "authenticated";

grant references on table "public"."project_applications" to "authenticated";

grant select on table "public"."project_applications" to "authenticated";

grant trigger on table "public"."project_applications" to "authenticated";

grant truncate on table "public"."project_applications" to "authenticated";

grant update on table "public"."project_applications" to "authenticated";

grant delete on table "public"."project_applications" to "service_role";

grant insert on table "public"."project_applications" to "service_role";

grant references on table "public"."project_applications" to "service_role";

grant select on table "public"."project_applications" to "service_role";

grant trigger on table "public"."project_applications" to "service_role";

grant truncate on table "public"."project_applications" to "service_role";

grant update on table "public"."project_applications" to "service_role";

grant delete on table "public"."project_comments" to "anon";

grant insert on table "public"."project_comments" to "anon";

grant references on table "public"."project_comments" to "anon";

grant select on table "public"."project_comments" to "anon";

grant trigger on table "public"."project_comments" to "anon";

grant truncate on table "public"."project_comments" to "anon";

grant update on table "public"."project_comments" to "anon";

grant delete on table "public"."project_comments" to "authenticated";

grant insert on table "public"."project_comments" to "authenticated";

grant references on table "public"."project_comments" to "authenticated";

grant select on table "public"."project_comments" to "authenticated";

grant trigger on table "public"."project_comments" to "authenticated";

grant truncate on table "public"."project_comments" to "authenticated";

grant update on table "public"."project_comments" to "authenticated";

grant delete on table "public"."project_comments" to "service_role";

grant insert on table "public"."project_comments" to "service_role";

grant references on table "public"."project_comments" to "service_role";

grant select on table "public"."project_comments" to "service_role";

grant trigger on table "public"."project_comments" to "service_role";

grant truncate on table "public"."project_comments" to "service_role";

grant update on table "public"."project_comments" to "service_role";

grant delete on table "public"."project_members" to "anon";

grant insert on table "public"."project_members" to "anon";

grant references on table "public"."project_members" to "anon";

grant select on table "public"."project_members" to "anon";

grant trigger on table "public"."project_members" to "anon";

grant truncate on table "public"."project_members" to "anon";

grant update on table "public"."project_members" to "anon";

grant delete on table "public"."project_members" to "authenticated";

grant insert on table "public"."project_members" to "authenticated";

grant references on table "public"."project_members" to "authenticated";

grant select on table "public"."project_members" to "authenticated";

grant trigger on table "public"."project_members" to "authenticated";

grant truncate on table "public"."project_members" to "authenticated";

grant update on table "public"."project_members" to "authenticated";

grant delete on table "public"."project_members" to "service_role";

grant insert on table "public"."project_members" to "service_role";

grant references on table "public"."project_members" to "service_role";

grant select on table "public"."project_members" to "service_role";

grant trigger on table "public"."project_members" to "service_role";

grant truncate on table "public"."project_members" to "service_role";

grant update on table "public"."project_members" to "service_role";

grant delete on table "public"."project_proposals" to "anon";

grant insert on table "public"."project_proposals" to "anon";

grant references on table "public"."project_proposals" to "anon";

grant select on table "public"."project_proposals" to "anon";

grant trigger on table "public"."project_proposals" to "anon";

grant truncate on table "public"."project_proposals" to "anon";

grant update on table "public"."project_proposals" to "anon";

grant delete on table "public"."project_proposals" to "authenticated";

grant insert on table "public"."project_proposals" to "authenticated";

grant references on table "public"."project_proposals" to "authenticated";

grant select on table "public"."project_proposals" to "authenticated";

grant trigger on table "public"."project_proposals" to "authenticated";

grant truncate on table "public"."project_proposals" to "authenticated";

grant update on table "public"."project_proposals" to "authenticated";

grant delete on table "public"."project_proposals" to "service_role";

grant insert on table "public"."project_proposals" to "service_role";

grant references on table "public"."project_proposals" to "service_role";

grant select on table "public"."project_proposals" to "service_role";

grant trigger on table "public"."project_proposals" to "service_role";

grant truncate on table "public"."project_proposals" to "service_role";

grant update on table "public"."project_proposals" to "service_role";

grant delete on table "public"."project_stats" to "anon";

grant insert on table "public"."project_stats" to "anon";

grant references on table "public"."project_stats" to "anon";

grant select on table "public"."project_stats" to "anon";

grant trigger on table "public"."project_stats" to "anon";

grant truncate on table "public"."project_stats" to "anon";

grant update on table "public"."project_stats" to "anon";

grant delete on table "public"."project_stats" to "authenticated";

grant insert on table "public"."project_stats" to "authenticated";

grant references on table "public"."project_stats" to "authenticated";

grant select on table "public"."project_stats" to "authenticated";

grant trigger on table "public"."project_stats" to "authenticated";

grant truncate on table "public"."project_stats" to "authenticated";

grant update on table "public"."project_stats" to "authenticated";

grant delete on table "public"."project_stats" to "service_role";

grant insert on table "public"."project_stats" to "service_role";

grant references on table "public"."project_stats" to "service_role";

grant select on table "public"."project_stats" to "service_role";

grant trigger on table "public"."project_stats" to "service_role";

grant truncate on table "public"."project_stats" to "service_role";

grant update on table "public"."project_stats" to "service_role";

grant delete on table "public"."projects" to "anon";

grant insert on table "public"."projects" to "anon";

grant references on table "public"."projects" to "anon";

grant select on table "public"."projects" to "anon";

grant trigger on table "public"."projects" to "anon";

grant truncate on table "public"."projects" to "anon";

grant update on table "public"."projects" to "anon";

grant delete on table "public"."projects" to "authenticated";

grant insert on table "public"."projects" to "authenticated";

grant references on table "public"."projects" to "authenticated";

grant select on table "public"."projects" to "authenticated";

grant trigger on table "public"."projects" to "authenticated";

grant truncate on table "public"."projects" to "authenticated";

grant update on table "public"."projects" to "authenticated";

grant delete on table "public"."projects" to "service_role";

grant insert on table "public"."projects" to "service_role";

grant references on table "public"."projects" to "service_role";

grant select on table "public"."projects" to "service_role";

grant trigger on table "public"."projects" to "service_role";

grant truncate on table "public"."projects" to "service_role";

grant update on table "public"."projects" to "service_role";

grant delete on table "public"."reviews" to "anon";

grant insert on table "public"."reviews" to "anon";

grant references on table "public"."reviews" to "anon";

grant select on table "public"."reviews" to "anon";

grant trigger on table "public"."reviews" to "anon";

grant truncate on table "public"."reviews" to "anon";

grant update on table "public"."reviews" to "anon";

grant delete on table "public"."reviews" to "authenticated";

grant insert on table "public"."reviews" to "authenticated";

grant references on table "public"."reviews" to "authenticated";

grant select on table "public"."reviews" to "authenticated";

grant trigger on table "public"."reviews" to "authenticated";

grant truncate on table "public"."reviews" to "authenticated";

grant update on table "public"."reviews" to "authenticated";

grant delete on table "public"."reviews" to "service_role";

grant insert on table "public"."reviews" to "service_role";

grant references on table "public"."reviews" to "service_role";

grant select on table "public"."reviews" to "service_role";

grant trigger on table "public"."reviews" to "service_role";

grant truncate on table "public"."reviews" to "service_role";

grant update on table "public"."reviews" to "service_role";

grant delete on table "public"."search_history" to "anon";

grant insert on table "public"."search_history" to "anon";

grant references on table "public"."search_history" to "anon";

grant select on table "public"."search_history" to "anon";

grant trigger on table "public"."search_history" to "anon";

grant truncate on table "public"."search_history" to "anon";

grant update on table "public"."search_history" to "anon";

grant delete on table "public"."search_history" to "authenticated";

grant insert on table "public"."search_history" to "authenticated";

grant references on table "public"."search_history" to "authenticated";

grant select on table "public"."search_history" to "authenticated";

grant trigger on table "public"."search_history" to "authenticated";

grant truncate on table "public"."search_history" to "authenticated";

grant update on table "public"."search_history" to "authenticated";

grant delete on table "public"."search_history" to "service_role";

grant insert on table "public"."search_history" to "service_role";

grant references on table "public"."search_history" to "service_role";

grant select on table "public"."search_history" to "service_role";

grant trigger on table "public"."search_history" to "service_role";

grant truncate on table "public"."search_history" to "service_role";

grant update on table "public"."search_history" to "service_role";

grant select on table "public"."server_notifications" to "anon";

grant delete on table "public"."server_notifications" to "authenticated";

grant insert on table "public"."server_notifications" to "authenticated";

grant select on table "public"."server_notifications" to "authenticated";

grant update on table "public"."server_notifications" to "authenticated";

grant delete on table "public"."server_notifications" to "service_role";

grant insert on table "public"."server_notifications" to "service_role";

grant references on table "public"."server_notifications" to "service_role";

grant select on table "public"."server_notifications" to "service_role";

grant trigger on table "public"."server_notifications" to "service_role";

grant truncate on table "public"."server_notifications" to "service_role";

grant update on table "public"."server_notifications" to "service_role";

grant delete on table "public"."user_badges" to "anon";

grant insert on table "public"."user_badges" to "anon";

grant references on table "public"."user_badges" to "anon";

grant select on table "public"."user_badges" to "anon";

grant trigger on table "public"."user_badges" to "anon";

grant truncate on table "public"."user_badges" to "anon";

grant update on table "public"."user_badges" to "anon";

grant delete on table "public"."user_badges" to "authenticated";

grant insert on table "public"."user_badges" to "authenticated";

grant references on table "public"."user_badges" to "authenticated";

grant select on table "public"."user_badges" to "authenticated";

grant trigger on table "public"."user_badges" to "authenticated";

grant truncate on table "public"."user_badges" to "authenticated";

grant update on table "public"."user_badges" to "authenticated";

grant delete on table "public"."user_badges" to "service_role";

grant insert on table "public"."user_badges" to "service_role";

grant references on table "public"."user_badges" to "service_role";

grant select on table "public"."user_badges" to "service_role";

grant trigger on table "public"."user_badges" to "service_role";

grant truncate on table "public"."user_badges" to "service_role";

grant update on table "public"."user_badges" to "service_role";

grant delete on table "public"."user_bookmarks" to "anon";

grant insert on table "public"."user_bookmarks" to "anon";

grant references on table "public"."user_bookmarks" to "anon";

grant select on table "public"."user_bookmarks" to "anon";

grant trigger on table "public"."user_bookmarks" to "anon";

grant truncate on table "public"."user_bookmarks" to "anon";

grant update on table "public"."user_bookmarks" to "anon";

grant delete on table "public"."user_bookmarks" to "authenticated";

grant insert on table "public"."user_bookmarks" to "authenticated";

grant references on table "public"."user_bookmarks" to "authenticated";

grant select on table "public"."user_bookmarks" to "authenticated";

grant trigger on table "public"."user_bookmarks" to "authenticated";

grant truncate on table "public"."user_bookmarks" to "authenticated";

grant update on table "public"."user_bookmarks" to "authenticated";

grant delete on table "public"."user_bookmarks" to "service_role";

grant insert on table "public"."user_bookmarks" to "service_role";

grant references on table "public"."user_bookmarks" to "service_role";

grant select on table "public"."user_bookmarks" to "service_role";

grant trigger on table "public"."user_bookmarks" to "service_role";

grant truncate on table "public"."user_bookmarks" to "service_role";

grant update on table "public"."user_bookmarks" to "service_role";

grant delete on table "public"."user_collaboration_preferences" to "anon";

grant insert on table "public"."user_collaboration_preferences" to "anon";

grant references on table "public"."user_collaboration_preferences" to "anon";

grant select on table "public"."user_collaboration_preferences" to "anon";

grant trigger on table "public"."user_collaboration_preferences" to "anon";

grant truncate on table "public"."user_collaboration_preferences" to "anon";

grant update on table "public"."user_collaboration_preferences" to "anon";

grant delete on table "public"."user_collaboration_preferences" to "authenticated";

grant insert on table "public"."user_collaboration_preferences" to "authenticated";

grant references on table "public"."user_collaboration_preferences" to "authenticated";

grant select on table "public"."user_collaboration_preferences" to "authenticated";

grant trigger on table "public"."user_collaboration_preferences" to "authenticated";

grant truncate on table "public"."user_collaboration_preferences" to "authenticated";

grant update on table "public"."user_collaboration_preferences" to "authenticated";

grant delete on table "public"."user_collaboration_preferences" to "service_role";

grant insert on table "public"."user_collaboration_preferences" to "service_role";

grant references on table "public"."user_collaboration_preferences" to "service_role";

grant select on table "public"."user_collaboration_preferences" to "service_role";

grant trigger on table "public"."user_collaboration_preferences" to "service_role";

grant truncate on table "public"."user_collaboration_preferences" to "service_role";

grant update on table "public"."user_collaboration_preferences" to "service_role";

grant delete on table "public"."user_notification_settings" to "anon";

grant insert on table "public"."user_notification_settings" to "anon";

grant references on table "public"."user_notification_settings" to "anon";

grant select on table "public"."user_notification_settings" to "anon";

grant trigger on table "public"."user_notification_settings" to "anon";

grant truncate on table "public"."user_notification_settings" to "anon";

grant update on table "public"."user_notification_settings" to "anon";

grant delete on table "public"."user_notification_settings" to "authenticated";

grant insert on table "public"."user_notification_settings" to "authenticated";

grant references on table "public"."user_notification_settings" to "authenticated";

grant select on table "public"."user_notification_settings" to "authenticated";

grant trigger on table "public"."user_notification_settings" to "authenticated";

grant truncate on table "public"."user_notification_settings" to "authenticated";

grant update on table "public"."user_notification_settings" to "authenticated";

grant delete on table "public"."user_notification_settings" to "service_role";

grant insert on table "public"."user_notification_settings" to "service_role";

grant references on table "public"."user_notification_settings" to "service_role";

grant select on table "public"."user_notification_settings" to "service_role";

grant trigger on table "public"."user_notification_settings" to "service_role";

grant truncate on table "public"."user_notification_settings" to "service_role";

grant update on table "public"."user_notification_settings" to "service_role";

grant delete on table "public"."user_notifications" to "anon";

grant insert on table "public"."user_notifications" to "anon";

grant references on table "public"."user_notifications" to "anon";

grant select on table "public"."user_notifications" to "anon";

grant trigger on table "public"."user_notifications" to "anon";

grant truncate on table "public"."user_notifications" to "anon";

grant update on table "public"."user_notifications" to "anon";

grant delete on table "public"."user_notifications" to "authenticated";

grant insert on table "public"."user_notifications" to "authenticated";

grant references on table "public"."user_notifications" to "authenticated";

grant select on table "public"."user_notifications" to "authenticated";

grant trigger on table "public"."user_notifications" to "authenticated";

grant truncate on table "public"."user_notifications" to "authenticated";

grant update on table "public"."user_notifications" to "authenticated";

grant delete on table "public"."user_notifications" to "service_role";

grant insert on table "public"."user_notifications" to "service_role";

grant references on table "public"."user_notifications" to "service_role";

grant select on table "public"."user_notifications" to "service_role";

grant trigger on table "public"."user_notifications" to "service_role";

grant truncate on table "public"."user_notifications" to "service_role";

grant update on table "public"."user_notifications" to "service_role";

grant delete on table "public"."user_partner_preferences" to "anon";

grant insert on table "public"."user_partner_preferences" to "anon";

grant references on table "public"."user_partner_preferences" to "anon";

grant select on table "public"."user_partner_preferences" to "anon";

grant trigger on table "public"."user_partner_preferences" to "anon";

grant truncate on table "public"."user_partner_preferences" to "anon";

grant update on table "public"."user_partner_preferences" to "anon";

grant delete on table "public"."user_partner_preferences" to "authenticated";

grant insert on table "public"."user_partner_preferences" to "authenticated";

grant references on table "public"."user_partner_preferences" to "authenticated";

grant select on table "public"."user_partner_preferences" to "authenticated";

grant trigger on table "public"."user_partner_preferences" to "authenticated";

grant truncate on table "public"."user_partner_preferences" to "authenticated";

grant update on table "public"."user_partner_preferences" to "authenticated";

grant delete on table "public"."user_partner_preferences" to "service_role";

grant insert on table "public"."user_partner_preferences" to "service_role";

grant references on table "public"."user_partner_preferences" to "service_role";

grant select on table "public"."user_partner_preferences" to "service_role";

grant trigger on table "public"."user_partner_preferences" to "service_role";

grant truncate on table "public"."user_partner_preferences" to "service_role";

grant update on table "public"."user_partner_preferences" to "service_role";

grant delete on table "public"."user_project_preferences" to "anon";

grant insert on table "public"."user_project_preferences" to "anon";

grant references on table "public"."user_project_preferences" to "anon";

grant select on table "public"."user_project_preferences" to "anon";

grant trigger on table "public"."user_project_preferences" to "anon";

grant truncate on table "public"."user_project_preferences" to "anon";

grant update on table "public"."user_project_preferences" to "anon";

grant delete on table "public"."user_project_preferences" to "authenticated";

grant insert on table "public"."user_project_preferences" to "authenticated";

grant references on table "public"."user_project_preferences" to "authenticated";

grant select on table "public"."user_project_preferences" to "authenticated";

grant trigger on table "public"."user_project_preferences" to "authenticated";

grant truncate on table "public"."user_project_preferences" to "authenticated";

grant update on table "public"."user_project_preferences" to "authenticated";

grant delete on table "public"."user_project_preferences" to "service_role";

grant insert on table "public"."user_project_preferences" to "service_role";

grant references on table "public"."user_project_preferences" to "service_role";

grant select on table "public"."user_project_preferences" to "service_role";

grant trigger on table "public"."user_project_preferences" to "service_role";

grant truncate on table "public"."user_project_preferences" to "service_role";

grant update on table "public"."user_project_preferences" to "service_role";

grant delete on table "public"."user_push_tokens" to "anon";

grant insert on table "public"."user_push_tokens" to "anon";

grant references on table "public"."user_push_tokens" to "anon";

grant select on table "public"."user_push_tokens" to "anon";

grant trigger on table "public"."user_push_tokens" to "anon";

grant truncate on table "public"."user_push_tokens" to "anon";

grant update on table "public"."user_push_tokens" to "anon";

grant delete on table "public"."user_push_tokens" to "authenticated";

grant insert on table "public"."user_push_tokens" to "authenticated";

grant references on table "public"."user_push_tokens" to "authenticated";

grant select on table "public"."user_push_tokens" to "authenticated";

grant trigger on table "public"."user_push_tokens" to "authenticated";

grant truncate on table "public"."user_push_tokens" to "authenticated";

grant update on table "public"."user_push_tokens" to "authenticated";

grant delete on table "public"."user_push_tokens" to "service_role";

grant insert on table "public"."user_push_tokens" to "service_role";

grant references on table "public"."user_push_tokens" to "service_role";

grant select on table "public"."user_push_tokens" to "service_role";

grant trigger on table "public"."user_push_tokens" to "service_role";

grant truncate on table "public"."user_push_tokens" to "service_role";

grant update on table "public"."user_push_tokens" to "service_role";

grant delete on table "public"."user_user_preferences" to "anon";

grant insert on table "public"."user_user_preferences" to "anon";

grant references on table "public"."user_user_preferences" to "anon";

grant select on table "public"."user_user_preferences" to "anon";

grant trigger on table "public"."user_user_preferences" to "anon";

grant truncate on table "public"."user_user_preferences" to "anon";

grant update on table "public"."user_user_preferences" to "anon";

grant delete on table "public"."user_user_preferences" to "authenticated";

grant insert on table "public"."user_user_preferences" to "authenticated";

grant references on table "public"."user_user_preferences" to "authenticated";

grant select on table "public"."user_user_preferences" to "authenticated";

grant trigger on table "public"."user_user_preferences" to "authenticated";

grant truncate on table "public"."user_user_preferences" to "authenticated";

grant update on table "public"."user_user_preferences" to "authenticated";

grant delete on table "public"."user_user_preferences" to "service_role";

grant insert on table "public"."user_user_preferences" to "service_role";

grant references on table "public"."user_user_preferences" to "service_role";

grant select on table "public"."user_user_preferences" to "service_role";

grant trigger on table "public"."user_user_preferences" to "service_role";

grant truncate on table "public"."user_user_preferences" to "service_role";

grant update on table "public"."user_user_preferences" to "service_role";


  create policy "Authenticated users can insert activity field keywords"
  on "public"."activity_field_keywords"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Authenticated users can update activity field keywords"
  on "public"."activity_field_keywords"
  as permissive
  for update
  to authenticated
using (true)
with check (true);



  create policy "Public can read activity field keywords"
  on "public"."activity_field_keywords"
  as permissive
  for select
  to public
using (true);



  create policy "Admins can insert activity logs"
  on "public"."admin_activity_logs"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Admins can view their own activity logs"
  on "public"."admin_activity_logs"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Admins with admin_management can delete admins"
  on "public"."admins"
  as permissive
  for delete
  to authenticated
using (public.has_admin_management_permission(auth.uid()));



  create policy "Admins with admin_management can insert admins"
  on "public"."admins"
  as permissive
  for insert
  to authenticated
with check (public.has_admin_management_permission(auth.uid()));



  create policy "Admins with admin_management can update admins"
  on "public"."admins"
  as permissive
  for update
  to authenticated
using (public.has_admin_management_permission(auth.uid()))
with check (public.has_admin_management_permission(auth.uid()));



  create policy "Admins with admin_management can view all admins"
  on "public"."admins"
  as permissive
  for select
  to authenticated
using (public.is_admin(auth.uid()));



  create policy "Allow authenticated users to read admins"
  on "public"."admins"
  as permissive
  for select
  to authenticated
using (true);



  create policy "admins_delete"
  on "public"."admins"
  as permissive
  for delete
  to authenticated
using (public.is_super_admin(auth.uid()));



  create policy "admins_insert"
  on "public"."admins"
  as permissive
  for insert
  to authenticated
with check (public.is_super_admin(auth.uid()));



  create policy "admins_select"
  on "public"."admins"
  as permissive
  for select
  to authenticated
using (public.is_admin(auth.uid()));



  create policy "admins_self_select"
  on "public"."admins"
  as permissive
  for select
  to authenticated
using ((profile_id = auth.uid()));



  create policy "admins_update"
  on "public"."admins"
  as permissive
  for update
  to authenticated
using (public.is_super_admin(auth.uid()))
with check (public.is_super_admin(auth.uid()));



  create policy "Public read access for badges"
  on "public"."badges"
  as permissive
  for select
  to public
using (true);



  create policy "Users can delete messages with permission"
  on "public"."chat_messages"
  as permissive
  for delete
  to public
using (((sender_id = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.chat_participants
  WHERE ((chat_participants.room_id = chat_messages.room_id) AND (chat_participants.user_id = auth.uid()) AND (chat_participants.role = ANY (ARRAY['owner'::public.chat_participant_role, 'admin'::public.chat_participant_role])))))));



  create policy "Users can insert messages in their rooms"
  on "public"."chat_messages"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.chat_participants
  WHERE ((chat_participants.room_id = chat_messages.room_id) AND (chat_participants.user_id = auth.uid())))));



  create policy "Users can view messages in their rooms"
  on "public"."chat_messages"
  as permissive
  for select
  to public
using ((EXISTS ( SELECT 1
   FROM public.chat_participants
  WHERE ((chat_participants.room_id = chat_messages.room_id) AND (chat_participants.user_id = auth.uid())))));



  create policy "Admins can delete chat participants"
  on "public"."chat_participants"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins a
  WHERE ((a.profile_id = auth.uid()) AND (('user_management'::text = ANY (a.permissions)) OR (a.role = 'super_admin'::text))))));



  create policy "Owners can update participants"
  on "public"."chat_participants"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.chat_participants cp
  WHERE ((cp.room_id = chat_participants.room_id) AND (cp.user_id = auth.uid()) AND (cp.role = 'owner'::public.chat_participant_role)))))
with check ((EXISTS ( SELECT 1
   FROM public.chat_participants cp
  WHERE ((cp.room_id = chat_participants.room_id) AND (cp.user_id = auth.uid()) AND (cp.role = 'owner'::public.chat_participant_role)))));



  create policy "Users can join chat rooms"
  on "public"."chat_participants"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Users can leave chat rooms"
  on "public"."chat_participants"
  as permissive
  for delete
  to public
using ((user_id = auth.uid()));



  create policy "Users can update their own participation"
  on "public"."chat_participants"
  as permissive
  for update
  to public
using ((user_id = auth.uid()))
with check ((user_id = auth.uid()));



  create policy "Users can view participants in their rooms"
  on "public"."chat_participants"
  as permissive
  for select
  to public
using (public.user_in_room(room_id, auth.uid()));



  create policy "Admins can create invitations"
  on "public"."chat_room_invitations"
  as permissive
  for insert
  to public
with check ((EXISTS ( SELECT 1
   FROM public.chat_participants
  WHERE ((chat_participants.room_id = chat_room_invitations.room_id) AND (chat_participants.user_id = auth.uid()) AND (chat_participants.role = ANY (ARRAY['owner'::public.chat_participant_role, 'admin'::public.chat_participant_role]))))));



  create policy "Invitees can update their invitations"
  on "public"."chat_room_invitations"
  as permissive
  for update
  to public
using ((invitee_id = auth.uid()));



  create policy "Inviters can withdraw invitations"
  on "public"."chat_room_invitations"
  as permissive
  for delete
  to public
using ((inviter_id = auth.uid()));



  create policy "Users can view their own invitations"
  on "public"."chat_room_invitations"
  as permissive
  for select
  to public
using (((inviter_id = auth.uid()) OR (invitee_id = auth.uid())));



  create policy "Admins can update room notice"
  on "public"."chat_rooms"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.chat_participants
  WHERE ((chat_participants.room_id = chat_rooms.id) AND (chat_participants.user_id = auth.uid()) AND (chat_participants.role = ANY (ARRAY['owner'::public.chat_participant_role, 'admin'::public.chat_participant_role]))))));



  create policy "Participants can update chat rooms"
  on "public"."chat_rooms"
  as permissive
  for update
  to public
using ((EXISTS ( SELECT 1
   FROM public.chat_participants
  WHERE ((chat_participants.room_id = chat_rooms.id) AND (chat_participants.user_id = auth.uid())))))
with check ((EXISTS ( SELECT 1
   FROM public.chat_participants
  WHERE ((chat_participants.room_id = chat_rooms.id) AND (chat_participants.user_id = auth.uid())))));



  create policy "Users can create chat rooms"
  on "public"."chat_rooms"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Users can view chat rooms"
  on "public"."chat_rooms"
  as permissive
  for select
  to authenticated
using (((EXISTS ( SELECT 1
   FROM public.chat_participants
  WHERE ((chat_participants.room_id = chat_rooms.id) AND (chat_participants.user_id = auth.uid())))) OR (EXISTS ( SELECT 1
   FROM public.projects
  WHERE ((projects.id = chat_rooms.project_id) AND (projects.created_by = auth.uid())))) OR (EXISTS ( SELECT 1
   FROM public.collaborations
  WHERE ((collaborations.id = chat_rooms.collaboration_id) AND (collaborations.created_by = auth.uid())))) OR (EXISTS ( SELECT 1
   FROM public.project_members
  WHERE ((project_members.project_id = chat_rooms.project_id) AND (project_members.user_id = auth.uid()) AND (project_members.status = 'active'::text)))) OR (EXISTS ( SELECT 1
   FROM public.collaboration_members
  WHERE ((collaboration_members.collaboration_id = chat_rooms.collaboration_id) AND (collaboration_members.user_id = auth.uid()) AND (collaboration_members.status = 'active'::text))))));



  create policy "Applicants can create applications"
  on "public"."collaboration_applications"
  as permissive
  for insert
  to public
with check ((auth.uid() = applicant_id));



  create policy "Applicants can hide their collab applications"
  on "public"."collaboration_applications"
  as permissive
  for update
  to authenticated
using ((auth.uid() = applicant_id))
with check ((auth.uid() = applicant_id));



  create policy "Applicants can update their own pending applications"
  on "public"."collaboration_applications"
  as permissive
  for update
  to public
using (((auth.uid() = applicant_id) AND (status = 'pending'::text)));



  create policy "Applicants can view their own applications"
  on "public"."collaboration_applications"
  as permissive
  for select
  to public
using ((auth.uid() = applicant_id));



  create policy "Applicants can withdraw their own collaboration applications"
  on "public"."collaboration_applications"
  as permissive
  for update
  to public
using (((auth.uid() = applicant_id) AND (status = ANY (ARRAY['pending'::text, 'reviewed'::text, 'shortlisted'::text]))))
with check (((auth.uid() = applicant_id) AND (status = 'withdrawn'::text)));



  create policy "Collab creators can hide applications"
  on "public"."collaboration_applications"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.collaborations
  WHERE ((collaborations.id = collaboration_applications.collaboration_id) AND (collaborations.created_by = auth.uid())))))
with check ((EXISTS ( SELECT 1
   FROM public.collaborations
  WHERE ((collaborations.id = collaboration_applications.collaboration_id) AND (collaborations.created_by = auth.uid())))));



  create policy "Collaboration creators can update applications to their collabo"
  on "public"."collaboration_applications"
  as permissive
  for update
  to public
using ((auth.uid() IN ( SELECT collaborations.created_by
   FROM public.collaborations
  WHERE (collaborations.id = collaboration_applications.collaboration_id))));



  create policy "Collaboration creators can view applications to their collabora"
  on "public"."collaboration_applications"
  as permissive
  for select
  to public
using ((auth.uid() IN ( SELECT collaborations.created_by
   FROM public.collaborations
  WHERE (collaborations.id = collaboration_applications.collaboration_id))));



  create policy "Invitees can hide their invitations"
  on "public"."collaboration_invitations"
  as permissive
  for update
  to authenticated
using ((auth.uid() = invitee_id))
with check ((auth.uid() = invitee_id));



  create policy "Invitees can respond to invitations"
  on "public"."collaboration_invitations"
  as permissive
  for update
  to public
using (((auth.uid() = invitee_id) AND (status = 'pending'::text)));



  create policy "Inviters can create invitations"
  on "public"."collaboration_invitations"
  as permissive
  for insert
  to public
with check ((auth.uid() = inviter_id));



  create policy "Inviters can hide their invitations"
  on "public"."collaboration_invitations"
  as permissive
  for update
  to authenticated
using ((auth.uid() = inviter_id))
with check ((auth.uid() = inviter_id));



  create policy "Inviters can update pending invitations"
  on "public"."collaboration_invitations"
  as permissive
  for update
  to public
using (((auth.uid() = inviter_id) AND (status = 'pending'::text)));



  create policy "Users can view invitations they sent or received"
  on "public"."collaboration_invitations"
  as permissive
  for select
  to public
using (((auth.uid() = inviter_id) OR (auth.uid() = invitee_id)));



  create policy "Admins can delete collaboration members"
  on "public"."collaboration_members"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins a
  WHERE ((a.profile_id = auth.uid()) AND (('user_management'::text = ANY (a.permissions)) OR (a.role = 'super_admin'::text))))));



  create policy "Anyone can view collaboration members"
  on "public"."collaboration_members"
  as permissive
  for select
  to public
using (true);



  create policy "Collaboration creators can manage members"
  on "public"."collaboration_members"
  as permissive
  for all
  to public
using ((auth.uid() IN ( SELECT collaborations.created_by
   FROM public.collaborations
  WHERE (collaborations.id = collaboration_members.collaboration_id))));



  create policy "Leaders can invite members (fixed)"
  on "public"."collaboration_members"
  as permissive
  for insert
  to public
with check (((auth.uid() IN ( SELECT collaborations.created_by
   FROM public.collaborations
  WHERE (collaborations.id = collaboration_members.collaboration_id))) OR public.is_collaboration_leader(collaboration_id, auth.uid())));



  create policy "Anyone can view collaboration stats"
  on "public"."collaboration_stats"
  as permissive
  for select
  to public
using (true);



  create policy "Collaboration creators can update stats"
  on "public"."collaboration_stats"
  as permissive
  for update
  to public
using ((collaboration_id IN ( SELECT collaborations.id
   FROM public.collaborations
  WHERE (collaborations.created_by = auth.uid()))));



  create policy "System can insert collab stats"
  on "public"."collaboration_stats"
  as permissive
  for insert
  to public
with check (true);



  create policy "Anyone can view collaborations"
  on "public"."collaborations"
  as permissive
  for select
  to public
using (true);



  create policy "Collab creator can soft delete"
  on "public"."collaborations"
  as permissive
  for update
  to authenticated
using ((created_by = auth.uid()))
with check ((created_by = auth.uid()));



  create policy "Owners and admins can delete collaborations"
  on "public"."collaborations"
  as permissive
  for delete
  to public
using (((created_by = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid())))));



  create policy "Owners and admins can update collaborations"
  on "public"."collaborations"
  as permissive
  for update
  to public
using (((created_by = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid())))));



  create policy "Partners and brands can create collaborations"
  on "public"."collaborations"
  as permissive
  for insert
  to public
with check (((created_by = auth.uid()) AND ((EXISTS ( SELECT 1
   FROM public.profile_artists pa
  WHERE ((pa.profile_id = auth.uid()) AND (pa.is_active = true)))) OR (EXISTS ( SELECT 1
   FROM public.profile_creatives pc
  WHERE ((pc.profile_id = auth.uid()) AND (pc.is_active = true)))) OR (EXISTS ( SELECT 1
   FROM public.profile_brands pb
  WHERE ((pb.profile_id = auth.uid()) AND (pb.is_active = true)))))));



  create policy "Admins can manage homepage slider images"
  on "public"."homepage_slider_images"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('content_management'::text = ANY (admins.permissions))))))
with check ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('content_management'::text = ANY (admins.permissions))))));



  create policy "Anyone can view homepage slider images"
  on "public"."homepage_slider_images"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Admins can manage homepage trending projects"
  on "public"."homepage_trending_projects"
  as permissive
  for all
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('content_management'::text = ANY (admins.permissions))))))
with check ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('content_management'::text = ANY (admins.permissions))))));



  create policy "Anyone can view homepage trending projects"
  on "public"."homepage_trending_projects"
  as permissive
  for select
  to public
using ((is_active = true));



  create policy "Admins can update inquiries"
  on "public"."inquiries"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('inquiry_management'::text = ANY (admins.permissions))))))
with check ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('inquiry_management'::text = ANY (admins.permissions))))));



  create policy "Admins can view all inquiries"
  on "public"."inquiries"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('inquiry_management'::text = ANY (admins.permissions))))));



  create policy "Users can create inquiries"
  on "public"."inquiries"
  as permissive
  for insert
  to authenticated
with check ((user_id = auth.uid()));



  create policy "Users can view their own inquiries"
  on "public"."inquiries"
  as permissive
  for select
  to authenticated
using ((user_id = auth.uid()));



  create policy "Users can delete their own bookmarks"
  on "public"."lounge_bookmarks"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert their own bookmarks"
  on "public"."lounge_bookmarks"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can view their own bookmarks"
  on "public"."lounge_bookmarks"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Anyone can view comment likes"
  on "public"."lounge_comment_likes"
  as permissive
  for select
  to public
using (true);



  create policy "Users can delete their own comment likes"
  on "public"."lounge_comment_likes"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert their own comment likes"
  on "public"."lounge_comment_likes"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Anyone can read comments"
  on "public"."lounge_comments"
  as permissive
  for select
  to public
using (true);



  create policy "Users can delete their own comments"
  on "public"."lounge_comments"
  as permissive
  for delete
  to public
using ((auth.uid() = author_id));



  create policy "Users can insert their own comments"
  on "public"."lounge_comments"
  as permissive
  for insert
  to public
with check ((auth.uid() = author_id));



  create policy "Users can update their own comments"
  on "public"."lounge_comments"
  as permissive
  for update
  to public
using ((auth.uid() = author_id));



  create policy "Users can delete their own likes"
  on "public"."lounge_likes"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert their own likes"
  on "public"."lounge_likes"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can view all likes"
  on "public"."lounge_likes"
  as permissive
  for select
  to public
using (true);



  create policy "Admins can delete magazines"
  on "public"."magazines"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Admins can insert magazines"
  on "public"."magazines"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Admins can read all magazines"
  on "public"."magazines"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Admins can update magazines"
  on "public"."magazines"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))))
with check ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Anyone can read published magazines"
  on "public"."magazines"
  as permissive
  for select
  to public
using ((status = 'published'::text));



  create policy "Project owner can detach magazine project"
  on "public"."magazines"
  as permissive
  for update
  to authenticated
using (((related_project IS NULL) OR (EXISTS ( SELECT 1
   FROM public.projects p
  WHERE ((p.id = magazines.related_project) AND (p.created_by = auth.uid()))))))
with check ((related_project IS NULL));



  create policy "Receivers can respond to partnership inquiries"
  on "public"."partnership_inquiries"
  as permissive
  for update
  to public
using ((auth.uid() = receiver_id));



  create policy "Senders can update their pending partnership inquiries"
  on "public"."partnership_inquiries"
  as permissive
  for update
  to public
using (((auth.uid() = sender_id) AND (status = 'pending'::text)));



  create policy "Users can create partnership inquiries"
  on "public"."partnership_inquiries"
  as permissive
  for insert
  to public
with check ((auth.uid() = sender_id));



  create policy "Users can insert partnership inquiries"
  on "public"."partnership_inquiries"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() = sender_id));



  create policy "Users can view partnership inquiries they sent or received"
  on "public"."partnership_inquiries"
  as permissive
  for select
  to public
using (((auth.uid() = sender_id) OR (auth.uid() = receiver_id)));



  create policy "Users can view their own inquiries"
  on "public"."partnership_inquiries"
  as permissive
  for select
  to authenticated
using (((auth.uid() = sender_id) OR (auth.uid() = receiver_id)));



  create policy "Admins can delete artists"
  on "public"."profile_artists"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND (('user_management'::text = ANY (admins.permissions)) OR (admins.role = 'super_admin'::text))))));



  create policy "Admins can update artist images"
  on "public"."profile_artists"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))))
with check ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Admins can view all artists"
  on "public"."profile_artists"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Anyone can view artists"
  on "public"."profile_artists"
  as permissive
  for select
  to public
using (true);



  create policy "Users can insert their own artist profile."
  on "public"."profile_artists"
  as permissive
  for insert
  to public
with check ((auth.uid() = profile_id));



  create policy "Users can update their own artist profile."
  on "public"."profile_artists"
  as permissive
  for update
  to public
using ((auth.uid() = profile_id));



  create policy "Users can view their own artist profile."
  on "public"."profile_artists"
  as permissive
  for select
  to public
using ((auth.uid() = profile_id));



  create policy "Admins can delete brands"
  on "public"."profile_brands"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND (('user_management'::text = ANY (admins.permissions)) OR (admins.role = 'super_admin'::text))))));



  create policy "Admins can update brand approval status"
  on "public"."profile_brands"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Admins can view all brands"
  on "public"."profile_brands"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Users can insert their own brand profile."
  on "public"."profile_brands"
  as permissive
  for insert
  to public
with check ((auth.uid() = profile_id));



  create policy "Users can update their own brand profile."
  on "public"."profile_brands"
  as permissive
  for update
  to public
using ((auth.uid() = profile_id));



  create policy "Users can view anybody's brand profile."
  on "public"."profile_brands"
  as permissive
  for select
  to authenticated
using (true);



  create policy "Admins can delete creatives"
  on "public"."profile_creatives"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND (('user_management'::text = ANY (admins.permissions)) OR (admins.role = 'super_admin'::text))))));



  create policy "Admins can update creative approval status"
  on "public"."profile_creatives"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Admins can view all creatives"
  on "public"."profile_creatives"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Anyone can view creatives"
  on "public"."profile_creatives"
  as permissive
  for select
  to public
using (true);



  create policy "Users can insert their own creative profile."
  on "public"."profile_creatives"
  as permissive
  for insert
  to public
with check ((auth.uid() = profile_id));



  create policy "Users can update their own creative profile."
  on "public"."profile_creatives"
  as permissive
  for update
  to public
using ((auth.uid() = profile_id));



  create policy "Users can view their own creative profile."
  on "public"."profile_creatives"
  as permissive
  for select
  to public
using ((auth.uid() = profile_id));



  create policy "Admins can delete fans"
  on "public"."profile_fans"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND (('user_management'::text = ANY (admins.permissions)) OR (admins.role = 'super_admin'::text))))));



  create policy "Admins can view all fans"
  on "public"."profile_fans"
  as permissive
  for select
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid()))));



  create policy "Users can insert their own fan profile."
  on "public"."profile_fans"
  as permissive
  for insert
  to public
with check ((auth.uid() = profile_id));



  create policy "Users can update their own fan profile."
  on "public"."profile_fans"
  as permissive
  for update
  to public
using ((auth.uid() = profile_id));



  create policy "Users can view their own fan profile."
  on "public"."profile_fans"
  as permissive
  for select
  to public
using ((auth.uid() = profile_id));



  create policy "Admins can update profiles banned_until"
  on "public"."profiles"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('user_management'::text = ANY (admins.permissions))))))
with check ((EXISTS ( SELECT 1
   FROM public.admins
  WHERE ((admins.profile_id = auth.uid()) AND ('user_management'::text = ANY (admins.permissions))))));



  create policy "Public profiles are viewable by everyone."
  on "public"."profiles"
  as permissive
  for select
  to public
using (true);



  create policy "Users can insert their own profile."
  on "public"."profiles"
  as permissive
  for insert
  to public
with check ((auth.uid() = id));



  create policy "Users can update own profile."
  on "public"."profiles"
  as permissive
  for update
  to public
using ((auth.uid() = id));



  create policy "Users can view own profile"
  on "public"."profiles"
  as permissive
  for select
  to public
using ((auth.uid() = id));



  create policy "Applicants can create applications"
  on "public"."project_applications"
  as permissive
  for insert
  to public
with check ((auth.uid() = applicant_id));



  create policy "Applicants can hide their applications"
  on "public"."project_applications"
  as permissive
  for update
  to authenticated
using ((auth.uid() = applicant_id))
with check ((auth.uid() = applicant_id));



  create policy "Applicants can update their own pending applications"
  on "public"."project_applications"
  as permissive
  for update
  to public
using (((auth.uid() = applicant_id) AND (status = 'pending'::text)));



  create policy "Applicants can view their own applications"
  on "public"."project_applications"
  as permissive
  for select
  to public
using ((auth.uid() = applicant_id));



  create policy "Applicants can withdraw their own applications"
  on "public"."project_applications"
  as permissive
  for update
  to public
using (((auth.uid() = applicant_id) AND (status = ANY (ARRAY['pending'::text, 'reviewed'::text, 'shortlisted'::text]))))
with check (((auth.uid() = applicant_id) AND (status = 'withdrawn'::text)));



  create policy "Project creators can update applications to their projects"
  on "public"."project_applications"
  as permissive
  for update
  to public
using ((auth.uid() IN ( SELECT projects.created_by
   FROM public.projects
  WHERE (projects.id = project_applications.project_id))));



  create policy "Project creators can view applications to their projects"
  on "public"."project_applications"
  as permissive
  for select
  to public
using ((auth.uid() IN ( SELECT projects.created_by
   FROM public.projects
  WHERE (projects.id = project_applications.project_id))));



  create policy "Reviewers can hide applications"
  on "public"."project_applications"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.projects
  WHERE ((projects.id = project_applications.project_id) AND (projects.created_by = auth.uid())))))
with check ((EXISTS ( SELECT 1
   FROM public.projects
  WHERE ((projects.id = project_applications.project_id) AND (projects.created_by = auth.uid())))));



  create policy "Anyone can view active comments"
  on "public"."project_comments"
  as permissive
  for select
  to public
using ((is_deleted = false));



  create policy "Users can create comments"
  on "public"."project_comments"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can delete their own comments"
  on "public"."project_comments"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can update their own comments"
  on "public"."project_comments"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Admins can delete project members"
  on "public"."project_members"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins a
  WHERE ((a.profile_id = auth.uid()) AND (('user_management'::text = ANY (a.permissions)) OR (a.role = 'super_admin'::text))))));



  create policy "Leaders can invite members"
  on "public"."project_members"
  as permissive
  for insert
  to public
with check (public.is_project_leader_with_invite(project_id, auth.uid()));



  create policy "Members can view members of their projects"
  on "public"."project_members"
  as permissive
  for select
  to public
using ((public.is_project_member(project_id, auth.uid()) OR public.is_project_creator(project_id, auth.uid())));



  create policy "Project creators can manage members"
  on "public"."project_members"
  as permissive
  for all
  to public
using (public.is_project_creator(project_id, auth.uid()))
with check (public.is_project_creator(project_id, auth.uid()));



  create policy "Users can add themselves when accepting proposals"
  on "public"."project_members"
  as permissive
  for insert
  to public
with check (((user_id = auth.uid()) AND public.can_add_self_as_member_via_proposal(project_id, auth.uid())));



  create policy "Receivers can hide their proposals"
  on "public"."project_proposals"
  as permissive
  for update
  to authenticated
using ((auth.uid() = receiver_id))
with check ((auth.uid() = receiver_id));



  create policy "Receivers can respond to proposals"
  on "public"."project_proposals"
  as permissive
  for update
  to authenticated
using (((auth.uid() = receiver_id) AND (status = ANY (ARRAY['pending'::text, 'viewed'::text]))))
with check (((auth.uid() = receiver_id) AND ((status = ANY (ARRAY['accepted'::text, 'rejected'::text])) OR (status = ANY (ARRAY['pending'::text, 'viewed'::text])))));



  create policy "Senders can create proposals"
  on "public"."project_proposals"
  as permissive
  for insert
  to public
with check ((auth.uid() = sender_id));



  create policy "Senders can hide their proposals"
  on "public"."project_proposals"
  as permissive
  for update
  to authenticated
using ((auth.uid() = sender_id))
with check ((auth.uid() = sender_id));



  create policy "Senders can update their proposals"
  on "public"."project_proposals"
  as permissive
  for update
  to authenticated
using (((auth.uid() = sender_id) AND (status = ANY (ARRAY['pending'::text, 'rejected'::text, 'expired'::text, 'withdrawn'::text]))))
with check (((auth.uid() = sender_id) AND (status = ANY (ARRAY['pending'::text, 'withdrawn'::text]))));



  create policy "Senders can withdraw their own proposals"
  on "public"."project_proposals"
  as permissive
  for update
  to public
using (((auth.uid() = sender_id) AND (status = 'pending'::text)))
with check (((auth.uid() = sender_id) AND (status = 'withdrawn'::text)));



  create policy "Users can view proposals they sent or received"
  on "public"."project_proposals"
  as permissive
  for select
  to public
using (((auth.uid() = sender_id) OR (auth.uid() = receiver_id)));



  create policy "Anyone can view project stats"
  on "public"."project_stats"
  as permissive
  for select
  to public
using (true);



  create policy "Project creators can update stats"
  on "public"."project_stats"
  as permissive
  for update
  to public
using ((project_id IN ( SELECT projects.id
   FROM public.projects
  WHERE (projects.created_by = auth.uid()))));



  create policy "System can insert stats"
  on "public"."project_stats"
  as permissive
  for insert
  to public
with check (true);



  create policy "Anyone can view projects"
  on "public"."projects"
  as permissive
  for select
  to public
using (true);



  create policy "Owners and admins can delete projects"
  on "public"."projects"
  as permissive
  for delete
  to public
using (((created_by = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid())))));



  create policy "Owners and admins can update projects"
  on "public"."projects"
  as permissive
  for update
  to public
using (((created_by = auth.uid()) OR (EXISTS ( SELECT 1
   FROM public.admins
  WHERE (admins.profile_id = auth.uid())))));



  create policy "Partners and brands can create projects"
  on "public"."projects"
  as permissive
  for insert
  to public
with check (((created_by = auth.uid()) AND ((EXISTS ( SELECT 1
   FROM public.profile_brands pb
  WHERE ((pb.profile_id = auth.uid()) AND (pb.is_active = true)))) OR (EXISTS ( SELECT 1
   FROM public.profile_artists pa
  WHERE ((pa.profile_id = auth.uid()) AND (pa.is_active = true)))) OR (EXISTS ( SELECT 1
   FROM public.profile_creatives pc
  WHERE ((pc.profile_id = auth.uid()) AND (pc.is_active = true)))))));



  create policy "Project creator can soft delete"
  on "public"."projects"
  as permissive
  for update
  to authenticated
using ((created_by = auth.uid()))
with check ((created_by = auth.uid()));



  create policy "Reviews are viewable by everyone"
  on "public"."reviews"
  as permissive
  for select
  to public
using ((is_visible = true));



  create policy "Users can create reviews"
  on "public"."reviews"
  as permissive
  for insert
  to public
with check ((auth.uid() = reviewer_id));



  create policy "Users can delete own reviews"
  on "public"."reviews"
  as permissive
  for delete
  to public
using (((auth.uid() = reviewer_id) AND (created_at > (now() - '24:00:00'::interval))));



  create policy "Users can update own reviews"
  on "public"."reviews"
  as permissive
  for update
  to public
using (((auth.uid() = reviewer_id) AND (created_at > (now() - '24:00:00'::interval))))
with check ((auth.uid() = reviewer_id));



  create policy "Users can delete their own search history"
  on "public"."search_history"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert their own search history"
  on "public"."search_history"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can view their own search history"
  on "public"."search_history"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "notification_delete_admin"
  on "public"."server_notifications"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins a
  WHERE (a.profile_id = auth.uid()))));



  create policy "notification_insert_admin"
  on "public"."server_notifications"
  as permissive
  for insert
  to authenticated
with check ((EXISTS ( SELECT 1
   FROM public.admins a
  WHERE (a.profile_id = auth.uid()))));



  create policy "notification_read_active"
  on "public"."server_notifications"
  as permissive
  for select
  to public
using (((is_active = true) AND (now() >= COALESCE(starts_at, '-infinity'::timestamp with time zone)) AND (now() <= COALESCE(ends_at, 'infinity'::timestamp with time zone))));



  create policy "notification_update_admin"
  on "public"."server_notifications"
  as permissive
  for update
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins a
  WHERE (a.profile_id = auth.uid()))))
with check (true);



  create policy "Public read access for user badges"
  on "public"."user_badges"
  as permissive
  for select
  to public
using (true);



  create policy "Users can create their own bookmarks"
  on "public"."user_bookmarks"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can delete their own bookmarks"
  on "public"."user_bookmarks"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can view their own bookmarks"
  on "public"."user_bookmarks"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Users can delete own collaboration preferences"
  on "public"."user_collaboration_preferences"
  as permissive
  for delete
  to public
using ((auth.uid() = profile_id));



  create policy "Users can insert own collaboration preferences"
  on "public"."user_collaboration_preferences"
  as permissive
  for insert
  to public
with check ((auth.uid() = profile_id));



  create policy "Users can update own collaboration preferences"
  on "public"."user_collaboration_preferences"
  as permissive
  for update
  to public
using ((auth.uid() = profile_id))
with check ((auth.uid() = profile_id));



  create policy "Users can view own collaboration preferences"
  on "public"."user_collaboration_preferences"
  as permissive
  for select
  to public
using ((auth.uid() = profile_id));



  create policy "Users can insert their own settings"
  on "public"."user_notification_settings"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update their own settings"
  on "public"."user_notification_settings"
  as permissive
  for update
  to public
using ((auth.uid() = user_id));



  create policy "Users can view their own settings"
  on "public"."user_notification_settings"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Admins can delete user notifications"
  on "public"."user_notifications"
  as permissive
  for delete
  to authenticated
using ((EXISTS ( SELECT 1
   FROM public.admins a
  WHERE ((a.profile_id = auth.uid()) AND (('user_management'::text = ANY (a.permissions)) OR (a.role = 'super_admin'::text))))));



  create policy "Users can insert notifications for others"
  on "public"."user_notifications"
  as permissive
  for insert
  to authenticated
with check (true);



  create policy "Users can update their own notifications (mark as read)"
  on "public"."user_notifications"
  as permissive
  for update
  to public
using ((auth.uid() = receiver_id));



  create policy "Users can view their own notifications"
  on "public"."user_notifications"
  as permissive
  for select
  to public
using ((auth.uid() = receiver_id));



  create policy "Users can delete own partner preferences"
  on "public"."user_partner_preferences"
  as permissive
  for delete
  to public
using ((auth.uid() = profile_id));



  create policy "Users can insert own partner preferences"
  on "public"."user_partner_preferences"
  as permissive
  for insert
  to public
with check ((auth.uid() = profile_id));



  create policy "Users can update own partner preferences"
  on "public"."user_partner_preferences"
  as permissive
  for update
  to public
using ((auth.uid() = profile_id))
with check ((auth.uid() = profile_id));



  create policy "Users can view own partner preferences"
  on "public"."user_partner_preferences"
  as permissive
  for select
  to public
using ((auth.uid() = profile_id));



  create policy "Users can delete own project preferences"
  on "public"."user_project_preferences"
  as permissive
  for delete
  to public
using ((auth.uid() = profile_id));



  create policy "Users can insert own project preferences"
  on "public"."user_project_preferences"
  as permissive
  for insert
  to public
with check ((auth.uid() = profile_id));



  create policy "Users can update own project preferences"
  on "public"."user_project_preferences"
  as permissive
  for update
  to public
using ((auth.uid() = profile_id))
with check ((auth.uid() = profile_id));



  create policy "Users can view own project preferences"
  on "public"."user_project_preferences"
  as permissive
  for select
  to public
using ((auth.uid() = profile_id));



  create policy "Users can delete their own push tokens"
  on "public"."user_push_tokens"
  as permissive
  for delete
  to public
using ((auth.uid() = user_id));



  create policy "Users can insert their own push tokens"
  on "public"."user_push_tokens"
  as permissive
  for insert
  to public
with check ((auth.uid() = user_id));



  create policy "Users can update their own push tokens"
  on "public"."user_push_tokens"
  as permissive
  for update
  to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));



  create policy "Users can view their own push tokens"
  on "public"."user_push_tokens"
  as permissive
  for select
  to public
using ((auth.uid() = user_id));



  create policy "Public read access for user preferences"
  on "public"."user_user_preferences"
  as permissive
  for select
  to public
using (true);



  create policy "Users can manage their own preferences"
  on "public"."user_user_preferences"
  as permissive
  for all
  to public
using ((auth.uid() = user_id))
with check ((auth.uid() = user_id));


CREATE TRIGGER update_admins_updated_at BEFORE UPDATE ON public.admins FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER on_chat_message_created AFTER INSERT ON public.chat_messages FOR EACH ROW EXECUTE FUNCTION public.handle_new_chat_message();

CREATE TRIGGER trigger_update_chat_room_invitations_updated_at BEFORE UPDATE ON public.chat_room_invitations FOR EACH ROW EXECUTE FUNCTION public.update_chat_room_invitations_updated_at();

CREATE TRIGGER on_collaboration_application_created AFTER INSERT ON public.collaboration_applications FOR EACH ROW EXECUTE FUNCTION public.handle_new_collaboration_application();

CREATE TRIGGER on_collaboration_application_withdrawn AFTER UPDATE ON public.collaboration_applications FOR EACH ROW WHEN (((old.status IS DISTINCT FROM new.status) AND (new.status = 'withdrawn'::text))) EXECUTE FUNCTION public.handle_collaboration_application_withdrawal();

CREATE TRIGGER update_collaboration_applications_updated_at BEFORE UPDATE ON public.collaboration_applications FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER on_invitation_created AFTER INSERT ON public.collaboration_invitations FOR EACH ROW EXECUTE FUNCTION public.handle_new_invitation();

CREATE TRIGGER update_invitations_updated_at BEFORE UPDATE ON public.collaboration_invitations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_collab_members_updated_at BEFORE UPDATE ON public.collaboration_members FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_collaboration_team_size_trigger AFTER INSERT OR DELETE OR UPDATE ON public.collaboration_members FOR EACH ROW EXECUTE FUNCTION public.update_current_team_size();

CREATE TRIGGER update_collaboration_stats_updated_at BEFORE UPDATE ON public.collaboration_stats FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_collaborations_updated_at BEFORE UPDATE ON public.collaborations FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_homepage_slider_images_updated_at BEFORE UPDATE ON public.homepage_slider_images FOR EACH ROW EXECUTE FUNCTION public.update_homepage_updated_at();

CREATE TRIGGER update_homepage_trending_projects_updated_at BEFORE UPDATE ON public.homepage_trending_projects FOR EACH ROW EXECUTE FUNCTION public.update_homepage_updated_at();

CREATE TRIGGER set_inquiry_username BEFORE INSERT OR UPDATE ON public.inquiries FOR EACH ROW EXECUTE FUNCTION public.update_inquiry_username();

CREATE TRIGGER on_partnership_inquiry_created AFTER INSERT ON public.partnership_inquiries FOR EACH ROW EXECUTE FUNCTION public.handle_new_partnership_inquiry();

CREATE TRIGGER update_partnership_inquiries_updated_at BEFORE UPDATE ON public.partnership_inquiries FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.profile_artists FOR EACH ROW EXECUTE FUNCTION public.moddatetime();

CREATE TRIGGER trg_artist_profile_insert_set_role AFTER INSERT ON public.profile_artists FOR EACH ROW EXECUTE FUNCTION public.update_user_role('{"artist"}');

CREATE TRIGGER trg_profile_artists_single_active BEFORE INSERT OR UPDATE OF is_active ON public.profile_artists FOR EACH ROW EXECUTE FUNCTION public.trg_profile_artists_single_active();

CREATE TRIGGER trg_update_role_on_artist_change AFTER INSERT OR UPDATE OF is_active ON public.profile_artists FOR EACH ROW EXECUTE FUNCTION public.trg_update_role_on_artist_change();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.profile_brands FOR EACH ROW EXECUTE FUNCTION public.moddatetime();

CREATE TRIGGER trg_brand_profile_insert_set_role AFTER INSERT ON public.profile_brands FOR EACH ROW EXECUTE FUNCTION public.update_user_role('{"brand"}');

CREATE TRIGGER trg_profile_brands_single_active BEFORE INSERT OR UPDATE OF is_active ON public.profile_brands FOR EACH ROW EXECUTE FUNCTION public.trg_profile_brands_single_active();

CREATE TRIGGER trg_update_role_on_brand_change AFTER INSERT OR UPDATE OF is_active ON public.profile_brands FOR EACH ROW EXECUTE FUNCTION public.trg_update_role_on_brand_change();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.profile_creatives FOR EACH ROW EXECUTE FUNCTION public.moddatetime();

CREATE TRIGGER trg_creative_profile_insert_set_role AFTER INSERT ON public.profile_creatives FOR EACH ROW EXECUTE FUNCTION public.update_user_role('{"creative"}');

CREATE TRIGGER trg_profile_creatives_single_active BEFORE INSERT OR UPDATE OF is_active ON public.profile_creatives FOR EACH ROW EXECUTE FUNCTION public.trg_profile_creatives_single_active();

CREATE TRIGGER trg_update_role_on_creative_change AFTER INSERT OR UPDATE OF is_active ON public.profile_creatives FOR EACH ROW EXECUTE FUNCTION public.trg_update_role_on_creative_change();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.profile_fans FOR EACH ROW EXECUTE FUNCTION public.moddatetime();

CREATE TRIGGER trg_fan_profile_insert_set_role AFTER INSERT ON public.profile_fans FOR EACH ROW EXECUTE FUNCTION public.update_user_role('{"fan"}');

CREATE TRIGGER trg_update_role_on_fan_change AFTER INSERT OR UPDATE OF is_active ON public.profile_fans FOR EACH ROW EXECUTE FUNCTION public.trg_update_role_on_fan_change();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.moddatetime();

CREATE TRIGGER on_project_application_created AFTER INSERT ON public.project_applications FOR EACH ROW EXECUTE FUNCTION public.handle_new_project_application();

CREATE TRIGGER on_project_application_withdrawn AFTER UPDATE ON public.project_applications FOR EACH ROW WHEN (((old.status IS DISTINCT FROM new.status) AND (new.status = 'withdrawn'::text))) EXECUTE FUNCTION public.handle_project_application_withdrawal();

CREATE TRIGGER update_applications_updated_at BEFORE UPDATE ON public.project_applications FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_comments_updated_at BEFORE UPDATE ON public.project_comments FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_project_member_team_size AFTER INSERT OR DELETE OR UPDATE ON public.project_members FOR EACH ROW EXECUTE FUNCTION public.update_project_team_size();

CREATE TRIGGER update_project_members_updated_at BEFORE UPDATE ON public.project_members FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER on_proposal_created AFTER INSERT ON public.project_proposals FOR EACH ROW EXECUTE FUNCTION public.handle_new_proposal();

CREATE TRIGGER on_proposal_withdrawn AFTER UPDATE ON public.project_proposals FOR EACH ROW WHEN (((old.status IS DISTINCT FROM new.status) AND (new.status = 'withdrawn'::text))) EXECUTE FUNCTION public.handle_proposal_withdrawal();

CREATE TRIGGER set_proposal_response_date BEFORE UPDATE ON public.project_proposals FOR EACH ROW WHEN (((old.status = ANY (ARRAY['pending'::text, 'viewed'::text])) AND (new.status = ANY (ARRAY['accepted'::text, 'rejected'::text])))) EXECUTE FUNCTION public.set_response_date();

CREATE TRIGGER set_proposal_viewed_date BEFORE UPDATE ON public.project_proposals FOR EACH ROW WHEN (((old.status = 'pending'::text) AND (new.status = 'viewed'::text))) EXECUTE FUNCTION public.set_viewed_date();

CREATE TRIGGER update_proposals_updated_at BEFORE UPDATE ON public.project_proposals FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_project_stats_updated_at BEFORE UPDATE ON public.project_stats FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON public.projects FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trigger_reviews_updated_at BEFORE UPDATE ON public.reviews FOR EACH ROW EXECUTE FUNCTION public.update_reviews_updated_at();

CREATE TRIGGER trg_notification_updated_at BEFORE UPDATE ON public.server_notifications FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

CREATE TRIGGER update_collaboration_bookmark_count_trigger AFTER INSERT OR DELETE ON public.user_bookmarks FOR EACH ROW EXECUTE FUNCTION public.update_collaboration_bookmark_count();

CREATE TRIGGER update_project_bookmark_count_trigger AFTER INSERT OR DELETE ON public.user_bookmarks FOR EACH ROW EXECUTE FUNCTION public.update_project_bookmark_count();

CREATE TRIGGER update_user_collaboration_preferences_updated_at BEFORE UPDATE ON public.user_collaboration_preferences FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_partner_preferences_updated_at BEFORE UPDATE ON public.user_partner_preferences FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER update_user_project_preferences_updated_at BEFORE UPDATE ON public.user_project_preferences FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();

CREATE TRIGGER trg_user_push_tokens_set_updated_at BEFORE UPDATE ON public.user_push_tokens FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();


  create policy "Allow authenticated users to upload 8ka4xq_0"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check ((auth.uid() IS NOT NULL));



  create policy "Anyone can view homepage-images"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'homepage-images'::text));



  create policy "Authenticated users can upload files"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'project-files'::text) OR (bucket_id = 'collaboration-files'::text)));



  create policy "Chat Attachments Auth Upload"
  on "storage"."objects"
  as permissive
  for insert
  to public
with check (((bucket_id = 'chat-attachments'::text) AND (auth.role() = 'authenticated'::text)));



  create policy "Chat Attachments Public Read"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'chat-attachments'::text));



  create policy "Public can download files"
  on "storage"."objects"
  as permissive
  for select
  to public
using (((bucket_id = 'project-files'::text) OR (bucket_id = 'collaboration-files'::text)));



  create policy "Public read access for homepage images"
  on "storage"."objects"
  as permissive
  for select
  to public
using ((bucket_id = 'homepage-images'::text));



  create policy "Users can delete their own files"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'project-files'::text) OR (bucket_id = 'collaboration-files'::text)));



  create policy "admins can delete homepage-images"
  on "storage"."objects"
  as permissive
  for delete
  to authenticated
using (((bucket_id = 'homepage-images'::text) AND (EXISTS ( SELECT 1
   FROM public.admins a
  WHERE (a.profile_id = auth.uid())))));



  create policy "admins can update homepage-images"
  on "storage"."objects"
  as permissive
  for update
  to authenticated
using (((bucket_id = 'homepage-images'::text) AND (EXISTS ( SELECT 1
   FROM public.admins a
  WHERE (a.profile_id = auth.uid())))));



  create policy "admins can upload homepage-images"
  on "storage"."objects"
  as permissive
  for insert
  to authenticated
with check (((bucket_id = 'homepage-images'::text) AND (EXISTS ( SELECT 1
   FROM public.admins a
  WHERE (a.profile_id = auth.uid())))));



  create policy "auth users can read homepage-images"
  on "storage"."objects"
  as permissive
  for select
  to authenticated
using ((bucket_id = 'homepage-images'::text));




