import{Server as b}from"@modelcontextprotocol/sdk/server/index.js";import{CallToolRequestSchema as S,ListResourcesRequestSchema as C,ListResourceTemplatesRequestSchema as U,ListToolsRequestSchema as P,ReadResourceRequestSchema as v}from"@modelcontextprotocol/sdk/types.js";import E from"zod-to-json-schema";function g(e){try{return new URL(e),e}catch{throw new Error(`invalid uri: ${e}`)}}function T(e,r){let o=new URL(e),a=new URL(r);return o.href===a.href}function w(e,r){let a=new URL(e).pathname.split("/").slice(1);for(let m of r){let s=new URL(m),t=decodeURIComponent(s.pathname).split("/").slice(1);if(a.length!==t.length)continue;let n={},l=!0;for(let i=0;i<a.length;i++){let u=t[i],R=a[i];if(!u||!R)break;if(u.startsWith("{")&&u.endsWith("}")){let f=u.slice(1,-1);if(!f)break;n[f]=R}else if(a[i]!==t[i]){l=!1;break}}if(l)return{uri:m,params:n}}}function L(e,r){return{uri:e,...r}}function q(e,r){return{uriTemplate:e,...r}}function I(e,r){return{uri:e,mimeType:"application/json",...r}}function z(e,r){return{uriTemplate:e,mimeType:"application/json",...r}}function J(e,r){return r.map(o=>{if("uri"in o){let s=new URL(o.uri,`${e}://`),t=decodeURI(s.href);return{...o,uri:t}}let a=new URL(o.uriTemplate,`${e}://`),m=decodeURI(a.href);return{...o,uriTemplate:m}})}function M(e,r){return{uri:e,mimeType:"application/json",text:JSON.stringify(r)}}function A(e){return e}function W(e){let r={};e.resources&&(r.resources={}),e.tools&&(r.tools={});let o=new b({name:e.name,title:e.title,version:e.version},{capabilities:r});async function a(){if(!e.resources)throw new Error("resources not available");return typeof e.resources=="function"?await e.resources():e.resources}async function m(){if(!e.tools)throw new Error("tools not available");return typeof e.tools=="function"?await e.tools():e.tools}return o.oninitialized=async()=>{let s=o.getClientVersion(),t=o.getClientCapabilities();if(!s)throw new Error("client info not available after initialization");if(!t)throw new Error("client capabilities not available after initialization");let n={clientInfo:s,clientCapabilities:t};await e.onInitialize?.(n)},e.resources&&(o.setRequestHandler(C,async()=>({resources:(await a()).filter(t=>"uri"in t).map(({uri:t,name:n,description:l,mimeType:i})=>({uri:t,name:n,description:l,mimeType:i}))})),o.setRequestHandler(U,async()=>({resourceTemplates:(await a()).filter(t=>"uriTemplate"in t).map(({uriTemplate:t,name:n,description:l,mimeType:i})=>({uriTemplate:t,name:n,description:l,mimeType:i}))})),o.setRequestHandler(v,async s=>{try{let t=await a(),{uri:n}=s.params,i=t.filter(c=>"uri"in c).find(c=>T(c.uri,n));if(i){let c=await i.read(n);return{contents:Array.isArray(c)?c:[c]}}let u=t.filter(c=>"uriTemplate"in c),R=u.map(({uriTemplate:c})=>g(c)),f=w(n,R);if(!f)throw new Error("resource not found");let y=u.find(c=>c.uriTemplate===f.uri);if(!y)throw new Error("resource not found");let p=await y.read(n,f.params);return{contents:Array.isArray(p)?p:[p]}}catch(t){return{isError:!0,content:[{type:"text",text:JSON.stringify({error:x(t)})}]}}})),e.tools&&(o.setRequestHandler(P,async()=>{let s=await m();return{tools:Object.entries(s).map(([t,{description:n,annotations:l,parameters:i}])=>{let u=E(i);if(!("properties"in u))throw new Error("tool parameters must be a ZodObject");return{name:t,description:n,annotations:l,inputSchema:u}})}}),o.setRequestHandler(S,async s=>{try{let t=await m(),n=s.params.name;if(!(n in t))throw new Error("tool not found");let l=t[n];if(!l)throw new Error("tool not found");let i=l.parameters.strict().parse(s.params.arguments??{}),R=await(async y=>{let p=await y.execute(i).then(d=>({success:!0,data:d})).catch(d=>({success:!1,error:d}));try{e.onToolCall?.({name:n,arguments:i,annotations:y.annotations,...p})}catch(d){console.error("Failed to run tool callback",d)}if(!p.success)throw p.error;return p.data})(l);return{content:R?[{type:"text",text:JSON.stringify(R)}]:[]}}catch(t){return{isError:!0,content:[{type:"text",text:JSON.stringify({error:x(t)})}]}}})),o}function x(e){if(!e||typeof e!="object")return e;let r={},o=["name","message"];for(let a of o)a in e&&(r[a]=e[a]);return r}var h=class{#e;#t;ready;readable;writable;onclose;onerror;onmessage;constructor(){let r,o,a=new Promise(s=>{r=s}),m=new Promise(s=>{o=s});this.ready=Promise.all([a,m]).then(()=>{}),this.readable=new ReadableStream({start:s=>{this.#e=s,r()}}),this.writable=new WritableStream({start:s=>{this.#t=s,o()},write:s=>{this.onmessage?.(s)}})}async start(){await this.ready}async send(r){if(!this.#e)throw new Error("readable stream not initialized");this.#e.enqueue(r)}async close(){this.#e?.error(new Error("connection closed")),this.#t?.error(new Error("connection closed")),this.onclose?.()}};export{h as StreamTransport,W as createMcpServer,I as jsonResource,M as jsonResourceResponse,z as jsonResourceTemplate,L as resource,q as resourceTemplate,J as resources,A as tool};
//# sourceMappingURL=index.js.map